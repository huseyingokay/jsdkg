import { d as debug } from '../browser-2f1afe46.js';

const log = debug("waku:libp2p-utils");
/**
 * Returns a pseudo-random peer that supports the given protocol.
 * Useful for protocols such as store and light push
 */
function selectRandomPeer(peers) {
    if (peers.length === 0)
        return;
    const index = Math.round(Math.random() * (peers.length - 1));
    return peers[index];
}
/**
 * Returns the list of peers that supports the given protocol.
 */
async function getPeersForProtocol(peerStore, protocols) {
    const peers = [];
    await peerStore.forEach((peer) => {
        for (let i = 0; i < protocols.length; i++) {
            if (peer.protocols.includes(protocols[i])) {
                peers.push(peer);
                break;
            }
        }
    });
    return peers;
}
async function selectPeerForProtocol(peerStore, protocols, peerId) {
    let peer;
    if (peerId) {
        peer = await peerStore.get(peerId);
        if (!peer) {
            throw new Error(`Failed to retrieve connection details for provided peer in peer store: ${peerId.toString()}`);
        }
    }
    else {
        const peers = await getPeersForProtocol(peerStore, protocols);
        peer = selectRandomPeer(peers);
        if (!peer) {
            throw new Error(`Failed to find known peer that registers protocols: ${protocols}`);
        }
    }
    let protocol;
    for (const codec of protocols) {
        if (peer.protocols.includes(codec)) {
            protocol = codec;
            // Do not break as we want to keep the last value
        }
    }
    log(`Using codec ${protocol}`);
    if (!protocol) {
        throw new Error(`Peer does not register required protocols (${peer.id.toString()}): ${protocols}`);
    }
    return { peer, protocol };
}
function selectConnection(connections) {
    if (!connections.length)
        return;
    if (connections.length === 1)
        return connections[0];
    let latestConnection;
    connections.forEach((connection) => {
        if (connection.stat.status === "OPEN") {
            if (!latestConnection) {
                latestConnection = connection;
            }
            else if (connection.stat.timeline.open > latestConnection.stat.timeline.open) {
                latestConnection = connection;
            }
        }
    });
    return latestConnection;
}

/**
 * A class with predefined helpers, to be used as a base to implement Waku
 * Protocols.
 */
class BaseProtocol {
    constructor(multicodec, peerStore, getConnections) {
        this.multicodec = multicodec;
        this.peerStore = peerStore;
        this.getConnections = getConnections;
    }
    /**
     * Returns known peers from the address book (`libp2p.peerStore`) that support
     * the class protocol. Waku may or may not be currently connected to these
     * peers.
     */
    async peers() {
        return getPeersForProtocol(this.peerStore, [this.multicodec]);
    }
    async getPeer(peerId) {
        const { peer } = await selectPeerForProtocol(this.peerStore, [this.multicodec], peerId);
        return peer;
    }
    async newStream(peer) {
        const connections = this.getConnections(peer.id);
        const connection = selectConnection(connections);
        if (!connection) {
            throw new Error("Failed to get a connection to the peer");
        }
        return connection.newStream(this.multicodec);
    }
}

export { BaseProtocol };
