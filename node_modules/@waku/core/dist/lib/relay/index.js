import { GossipSub, } from "@chainsafe/libp2p-gossipsub";
import { SignaturePolicy } from "@chainsafe/libp2p-gossipsub/types";
import debug from "debug";
import { DefaultPubSubTopic } from "../constants.js";
import { groupByContentTopic } from "../group_by.js";
import { TopicOnlyDecoder } from "../message/topic_only_message.js";
import * as constants from "./constants.js";
import { messageValidator } from "./message_validator.js";
const log = debug("waku:relay");
/**
 * Implements the [Waku v2 Relay protocol](https://rfc.vac.dev/spec/11/).
 * Throws if libp2p.pubsub does not support Waku Relay
 */
class Relay {
    constructor(libp2p, options) {
        if (!this.isRelayPubSub(libp2p.pubsub)) {
            throw Error(`Failed to initialize Relay. libp2p.pubsub does not support ${Relay.multicodec}`);
        }
        this.gossipSub = libp2p.pubsub;
        this.pubSubTopic = options?.pubSubTopic ?? DefaultPubSubTopic;
        if (this.gossipSub.isStarted()) {
            this.gossipSubSubscribe(this.pubSubTopic);
        }
        this.observers = new Map();
        // TODO: User might want to decide what decoder should be used (e.g. for RLN)
        this.defaultDecoder = new TopicOnlyDecoder();
    }
    /**
     * Mounts the gossipsub protocol onto the libp2p node
     * and subscribes to the default topic.
     *
     * @override
     * @returns {void}
     */
    async start() {
        if (this.gossipSub.isStarted()) {
            throw Error("GossipSub already started.");
        }
        await this.gossipSub.start();
        this.gossipSubSubscribe(this.pubSubTopic);
    }
    /**
     * Send Waku message.
     */
    async send(encoder, message) {
        const msg = await encoder.toWire(message);
        if (!msg) {
            log("Failed to encode message, aborting publish");
            return { recipients: [] };
        }
        return this.gossipSub.publish(this.pubSubTopic, msg);
    }
    /**
     * Add an observer and associated Decoder to process incoming messages on a given content topic.
     *
     * @returns Function to delete the observer
     */
    subscribe(decoders, callback) {
        const contentTopicToObservers = Array.isArray(decoders)
            ? toObservers(decoders, callback)
            : toObservers([decoders], callback);
        for (const contentTopic of contentTopicToObservers.keys()) {
            const currObservers = this.observers.get(contentTopic) || new Set();
            const newObservers = contentTopicToObservers.get(contentTopic) || new Set();
            this.observers.set(contentTopic, union(currObservers, newObservers));
        }
        return () => {
            for (const contentTopic of contentTopicToObservers.keys()) {
                const currentObservers = this.observers.get(contentTopic) || new Set();
                const observersToRemove = contentTopicToObservers.get(contentTopic) || new Set();
                const nextObservers = leftMinusJoin(currentObservers, observersToRemove);
                if (nextObservers.size) {
                    this.observers.set(contentTopic, nextObservers);
                }
                else {
                    this.observers.delete(contentTopic);
                }
            }
        };
    }
    getActiveSubscriptions() {
        const map = new Map();
        map.set(this.pubSubTopic, this.observers.keys());
        return map;
    }
    getMeshPeers(topic) {
        return this.gossipSub.getMeshPeers(topic ?? this.pubSubTopic);
    }
    async processIncomingMessage(pubSubTopic, bytes) {
        const topicOnlyMsg = await this.defaultDecoder.fromWireToProtoObj(bytes);
        if (!topicOnlyMsg || !topicOnlyMsg.contentTopic) {
            log("Message does not have a content topic, skipping");
            return;
        }
        const observers = this.observers.get(topicOnlyMsg.contentTopic);
        if (!observers) {
            return;
        }
        await Promise.all(Array.from(observers).map(async ({ decoder, callback }) => {
            const protoMsg = await decoder.fromWireToProtoObj(bytes);
            if (!protoMsg) {
                log("Internal error: message previously decoded failed on 2nd pass.");
                return;
            }
            const msg = await decoder.fromProtoObj(pubSubTopic, protoMsg);
            if (msg) {
                callback(msg);
            }
            else {
                log("Failed to decode messages on", topicOnlyMsg.contentTopic);
            }
        }));
    }
    /**
     * Subscribe to a pubsub topic and start emitting Waku messages to observers.
     *
     * @override
     */
    gossipSubSubscribe(pubSubTopic) {
        this.gossipSub.addEventListener("gossipsub:message", async (event) => {
            if (event.detail.msg.topic !== pubSubTopic)
                return;
            log(`Message received on ${pubSubTopic}`);
            this.processIncomingMessage(event.detail.msg.topic, event.detail.msg.data).catch((e) => log("Failed to process incoming message", e));
        });
        this.gossipSub.topicValidators.set(pubSubTopic, messageValidator);
        this.gossipSub.subscribe(pubSubTopic);
    }
    isRelayPubSub(pubsub) {
        return pubsub?.multicodecs?.includes(Relay.multicodec) || false;
    }
}
Relay.multicodec = constants.RelayCodecs[0];
export function wakuRelay(init = {}) {
    return (libp2p) => new Relay(libp2p, init);
}
export function wakuGossipSub(init = {}) {
    return (components) => {
        init = {
            ...init,
            // Ensure that no signature is included nor expected in the messages.
            globalSignaturePolicy: SignaturePolicy.StrictNoSign,
            fallbackToFloodsub: false,
        };
        const pubsub = new GossipSub(components, init);
        pubsub.multicodecs = constants.RelayCodecs;
        return pubsub;
    };
}
function toObservers(decoders, callback) {
    const contentTopicToDecoders = Array.from(groupByContentTopic(decoders).entries());
    const contentTopicToObserversEntries = contentTopicToDecoders.map(([contentTopic, decoders]) => [
        contentTopic,
        new Set(decoders.map((decoder) => ({
            decoder,
            callback,
        }))),
    ]);
    return new Map(contentTopicToObserversEntries);
}
function union(left, right) {
    for (const val of right.values()) {
        left.add(val);
    }
    return left;
}
function leftMinusJoin(left, right) {
    for (const val of right.values()) {
        if (left.has(val)) {
            left.delete(val);
        }
    }
    return left;
}
//# sourceMappingURL=index.js.map