"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StandardCoin = void 0;
const bignumber_1 = require("@ethersproject/bignumber");
const smart_coin_1 = require("./smart_coin");
const util_1 = require("./util");
class StandardCoin extends smart_coin_1.SmartCoin {
    constructor({ parentCoinInfo = null, puzzleHash = null, amount = null, coin = null, solution = null, publicKey = null, syntheticKey = null, } = {}) {
        super({
            parentCoinInfo, puzzleHash, amount, coin, solution
        });
        this.syntheticKey = null;
        let synthKey = null;
        if (publicKey !== null && publicKey !== undefined) {
            synthKey = util_1.Util.sexp.calculateSyntheticPublicKey(util_1.Util.key.hexToPublicKey(publicKey));
            this.syntheticKey = util_1.Util.key.publicKeyToHex(synthKey);
        }
        else if (syntheticKey !== null && syntheticKey !== undefined) {
            synthKey = util_1.Util.key.hexToPublicKey(syntheticKey);
            this.syntheticKey = syntheticKey;
        }
        if (synthKey !== null) {
            this.puzzle = this.getPuzzleForSyntheticPublicKey(synthKey);
            this.calculatePuzzleHash();
        }
    }
    copyWith({ parentCoinInfo = null, puzzleHash = null, amount = null, coin = null, solution = null, publicKey = null, syntheticKey = null, }) {
        return new StandardCoin({
            parentCoinInfo: parentCoinInfo !== null && parentCoinInfo !== void 0 ? parentCoinInfo : this.parentCoinInfo,
            puzzleHash: puzzleHash !== null && puzzleHash !== void 0 ? puzzleHash : this.puzzleHash,
            amount: amount !== null && amount !== void 0 ? amount : this.amount,
            solution: solution !== null && solution !== void 0 ? solution : this.solution,
            coin,
            publicKey: publicKey,
            syntheticKey: syntheticKey !== null && syntheticKey !== void 0 ? syntheticKey : this.syntheticKey,
        });
    }
    getPuzzleForSyntheticPublicKey(publicKey) {
        return util_1.Util.sexp.standardCoinPuzzle(publicKey, true);
    }
    withPublicKey(publicKey) {
        return this.copyWith({
            publicKey,
        });
    }
    withSyntheticKey(syntheticKey) {
        return this.copyWith({
            syntheticKey,
        });
    }
    withParentCoinInfo(parentCoinInfo) {
        return this.copyWith({
            parentCoinInfo,
        });
    }
    withPuzzleHash(puzzleHash) {
        return this.copyWith({
            puzzleHash,
        });
    }
    withAmount(amount) {
        return this.copyWith({
            amount: bignumber_1.BigNumber.from(amount),
        });
    }
    addConditionsToSolution(conditions) {
        if (this.solution === null) {
            this.solution = util_1.Util.sexp.standardCoinSolution([]);
        }
        try {
            const e = [];
            for (const elem of this.solution.as_iter()) {
                e.push(elem);
            }
            if (e.length !== 3)
                return this;
            const conditionList = [];
            const cl = e[1];
            let first = true;
            for (const elem of cl.as_iter()) {
                if (first) {
                    first = false;
                }
                else {
                    conditionList.push(elem);
                }
            }
            for (const elem of conditions) {
                conditionList.push(elem);
            }
            return this.copyWith({
                solution: util_1.Util.sexp.standardCoinSolution(conditionList),
            });
        }
        catch (_) {
            return this;
        }
    }
}
exports.StandardCoin = StandardCoin;
//# sourceMappingURL=standard_coin.js.map