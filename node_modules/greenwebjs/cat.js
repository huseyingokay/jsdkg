"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CAT = void 0;
const bignumber_1 = require("@ethersproject/bignumber");
const clvm_1 = require("clvm");
const smart_coin_1 = require("./smart_coin");
const util_1 = require("./util");
const condition_opcodes_1 = require("./util/sexp/condition_opcodes");
const provider_types_1 = require("./xch/providers/provider_types");
class CAT extends smart_coin_1.SmartCoin {
    constructor({ parentCoinInfo = null, puzzleHash = null, amount = null, coin = null, TAILProgramHash = null, publicKey = null, syntheticKey = null, innerSolution = null, prevCoinId = null, nextCoin = null, prevSubtotal = null, extraDelta = null, TAILProgram = null, TAILSolution = null, lineageProof = null, } = {}) {
        var _a, _b;
        super({
            parentCoinInfo, puzzleHash, amount, coin
        });
        this.TAILProgramHash = null;
        this.innerPuzzle = null;
        this.innerPuzzleHash = null;
        this.syntheticKey = null;
        this.innerSolution = null;
        this.prevCoinId = null;
        this.nextCoin = null;
        this.prevSubtotal = null;
        this.extraDelta = null;
        this.TAILProgram = null;
        this.TAILSolution = null;
        this.lineageProof = null;
        this.TAILProgramHash = util_1.Util.dehexlify(TAILProgramHash);
        this.innerSolution = innerSolution;
        this.prevCoinId = util_1.Util.dehexlify(prevCoinId);
        if (nextCoin !== null && nextCoin !== undefined) {
            this.nextCoin = nextCoin;
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.nextCoin.parentCoinInfo = util_1.Util.dehexlify(nextCoin.parentCoinInfo);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.nextCoin.puzzleHash = util_1.Util.dehexlify(nextCoin.puzzleHash);
        }
        if (prevSubtotal !== null && prevSubtotal !== undefined) {
            this.prevSubtotal = bignumber_1.BigNumber.from(prevSubtotal);
        }
        if (extraDelta !== null && extraDelta !== undefined) {
            this.extraDelta = bignumber_1.BigNumber.from(extraDelta);
        }
        this.TAILProgram = TAILProgram;
        this.TAILSolution = TAILSolution;
        if (lineageProof !== null && lineageProof !== undefined) {
            this.lineageProof = {
                amount: lineageProof.amount ? bignumber_1.BigNumber.from(lineageProof.amount) : null,
                parentName: util_1.Util.dehexlify((_a = lineageProof.parentName) !== null && _a !== void 0 ? _a : null),
                innerPuzzleHash: util_1.Util.dehexlify((_b = lineageProof.innerPuzzleHash) !== null && _b !== void 0 ? _b : null),
            };
        }
        let synthKey = null;
        if (publicKey !== null && publicKey !== undefined) {
            synthKey = util_1.Util.sexp.calculateSyntheticPublicKey(util_1.Util.key.hexToPublicKey(publicKey));
            this.syntheticKey = util_1.Util.key.publicKeyToHex(synthKey);
        }
        else if (syntheticKey !== null && syntheticKey !== undefined) {
            synthKey = util_1.Util.key.hexToPublicKey(syntheticKey);
            this.syntheticKey = syntheticKey;
        }
        if (synthKey !== null) {
            this.syntheticKey = util_1.Util.key.publicKeyToHex(synthKey);
            this.innerPuzzle = util_1.Util.sexp.standardCoinPuzzle(synthKey, true);
            this.innerPuzzleHash = util_1.Util.sexp.sha256tree(this.innerPuzzle);
        }
        this.deriveTAILProgramAndSolutionFromSolution();
        this.constructInnerSolution();
        this.constructPuzzle();
        this.calculateTAILPuzzleHash();
        this.constructSolution();
    }
    deriveTAILProgramAndSolutionFromSolution() {
        var _a;
        if (this.innerPuzzle === null || this.innerSolution === null)
            return;
        const res = util_1.Util.sexp.conditionsDictForSolution(
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.innerPuzzle, 
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.innerSolution, util_1.Util.sexp.MAX_BLOCK_COST_CLVM);
        if (res[0])
            return;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const conditionsDict = res[1];
        for (const _ of ((_a = conditionsDict.get(condition_opcodes_1.ConditionOpcode.CREATE_COIN)) !== null && _a !== void 0 ? _a : [])) {
            if (_.vars[1] === "8f" && _.vars.length >= 4) { // -113 in bytes
                this.TAILProgram = util_1.Util.sexp.fromHex(_.vars[2]);
                this.TAILSolution = util_1.Util.sexp.fromHex(_.vars[3]);
                this.calculateTAILPuzzleHash();
                break;
            }
        }
    }
    constructPuzzle() {
        if (this.TAILProgramHash === null || this.innerPuzzle === null)
            return;
        this.puzzle = util_1.Util.sexp.CATPuzzle(this.TAILProgramHash, this.innerPuzzle);
        this.calculatePuzzleHash();
    }
    calculateTAILPuzzleHash() {
        if (this.TAILProgram === null)
            return;
        this.TAILProgramHash = util_1.Util.sexp.sha256tree(this.TAILProgram);
    }
    constructInnerSolution() {
        if (this.innerSolution !== null)
            return;
        if (this.TAILProgram === null || this.TAILSolution === null)
            return;
        if (this.extraDelta === null || bignumber_1.BigNumber.from(this.extraDelta).eq(0))
            return;
        this.innerSolution = util_1.Util.sexp.standardCoinSolution([
            clvm_1.SExp.to([
                util_1.Util.sexp.bytesToAtom(condition_opcodes_1.ConditionOpcode.CREATE_COIN),
                clvm_1.Bytes.from("yakuhitoyakuhitoyakuhitoyakuhito"),
                util_1.Util.sexp.bytesToAtom("8f"),
                this.TAILProgram,
                this.TAILSolution
            ]),
        ]);
    }
    lineageProofToProgram() {
        if (!this.lineageProof ||
            !this.lineageProof.amount ||
            !this.lineageProof.innerPuzzleHash ||
            !this.lineageProof.parentName) {
            return null;
        }
        const c = new provider_types_1.Coin();
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        c.parentCoinInfo = this.lineageProof.parentName;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        c.puzzleHash = this.lineageProof.innerPuzzleHash;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        c.amount = this.lineageProof.amount;
        return util_1.Util.coin.toProgram(c);
    }
    constructSolution() {
        var _a, _b, _c, _d;
        if (this.innerSolution === null || !this.hasCoinInfo())
            return;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const thisCoin = this.toCoin();
        this.solution = util_1.Util.sexp.CATSolution(this.innerSolution, this.lineageProofToProgram(), (_a = this.prevCoinId) !== null && _a !== void 0 ? _a : util_1.Util.coin.getId(thisCoin), 
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.toCoin(), (_b = this.nextCoin) !== null && _b !== void 0 ? _b : thisCoin, (_c = this.prevSubtotal) !== null && _c !== void 0 ? _c : 0, (_d = this.extraDelta) !== null && _d !== void 0 ? _d : 0);
    }
    copyWith({ parentCoinInfo = null, puzzleHash = null, amount = null, coin = null, TAILProgramHash = null, innerSolution = null, prevCoinId = null, nextCoin = null, prevSubtotal = null, publicKey = null, syntheticKey = null, extraDelta = null, TAILProgram = null, TAILSolution = null, lineageProof = null, }) {
        return new CAT({
            parentCoinInfo: parentCoinInfo !== null && parentCoinInfo !== void 0 ? parentCoinInfo : this.parentCoinInfo,
            puzzleHash: puzzleHash !== null && puzzleHash !== void 0 ? puzzleHash : this.puzzleHash,
            amount: amount !== null && amount !== void 0 ? amount : this.amount,
            coin: coin,
            TAILProgramHash: TAILProgramHash !== null && TAILProgramHash !== void 0 ? TAILProgramHash : this.TAILProgramHash,
            publicKey: publicKey,
            syntheticKey: syntheticKey !== null && syntheticKey !== void 0 ? syntheticKey : this.syntheticKey,
            innerSolution: innerSolution !== null && innerSolution !== void 0 ? innerSolution : this.innerSolution,
            prevCoinId: prevCoinId !== null && prevCoinId !== void 0 ? prevCoinId : this.prevCoinId,
            nextCoin: nextCoin !== null && nextCoin !== void 0 ? nextCoin : this.nextCoin,
            prevSubtotal: prevSubtotal !== null && prevSubtotal !== void 0 ? prevSubtotal : this.prevSubtotal,
            extraDelta: extraDelta !== null && extraDelta !== void 0 ? extraDelta : this.extraDelta,
            TAILProgram: TAILProgram !== null && TAILProgram !== void 0 ? TAILProgram : this.TAILProgram,
            TAILSolution: TAILSolution !== null && TAILSolution !== void 0 ? TAILSolution : this.TAILSolution,
            lineageProof: lineageProof !== null && lineageProof !== void 0 ? lineageProof : this.lineageProof,
        });
    }
    withParentCoinInfo(parentCoinInfo) {
        return this.copyWith({
            parentCoinInfo,
        });
    }
    withPuzzleHash(puzzleHash) {
        return this.copyWith({
            puzzleHash,
        });
    }
    withAmount(amount) {
        return this.copyWith({
            amount,
        });
    }
    withTAILProgramHash(TAILProgramHash) {
        return this.copyWith({
            TAILProgramHash,
        });
    }
    withPublicKey(publicKey) {
        return this.copyWith({
            publicKey,
        });
    }
    withSyntheticKey(syntheticKey) {
        return this.copyWith({
            syntheticKey,
        });
    }
    withInnerSolution(innerSolution) {
        return this.copyWith({
            innerSolution,
        });
    }
    withExtraDelta(extraDelta) {
        return this.copyWith({
            extraDelta,
        });
    }
    withTAILProgram(TAILProgram) {
        return this.copyWith({
            TAILProgram,
        });
    }
    withTAILSolution(TAILSolution) {
        return this.copyWith({
            TAILSolution,
        });
    }
    withLineageProof(lineageProof) {
        return this.copyWith({
            lineageProof,
        });
    }
    addConditionsToInnerSolution(conditions) {
        if (this.innerSolution === null) {
            this.innerSolution = util_1.Util.sexp.standardCoinSolution([]);
        }
        try {
            const e = [];
            for (const elem of this.innerSolution.as_iter()) {
                e.push(elem);
            }
            if (e.length !== 3)
                return this;
            const conditionList = [];
            const cl = e[1];
            let first = true;
            for (const elem of cl.as_iter()) {
                if (first) {
                    first = false;
                }
                else {
                    conditionList.push(elem);
                }
            }
            for (const elem of conditions) {
                conditionList.push(elem);
            }
            return this.copyWith({
                innerSolution: util_1.Util.sexp.standardCoinSolution(conditionList),
            });
        }
        catch (_) {
            return this;
        }
    }
}
exports.CAT = CAT;
//# sourceMappingURL=cat.js.map