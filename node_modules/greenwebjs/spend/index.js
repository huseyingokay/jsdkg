"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SpendModule = exports.Announcement = void 0;
const bignumber_1 = require("@ethersproject/bignumber");
const clvm_1 = require("clvm");
const cat_1 = require("../cat");
const singleton_1 = require("../singleton");
const standard_coin_1 = require("../standard_coin");
const util_1 = require("../util");
const coin_spend_1 = require("../util/serializer/types/coin_spend");
const spend_bundle_1 = require("../util/serializer/types/spend_bundle");
const condition_opcodes_1 = require("../util/sexp/condition_opcodes");
const provider_types_1 = require("../xch/providers/provider_types");
class Announcement {
    constructor(originInfo, message, morphBytes) {
        this.originInfo = originInfo;
        this.message = message;
        this.morphBytes = morphBytes;
    }
    name() {
        var _a, _b;
        const toHash = ((_a = this.originInfo) !== null && _a !== void 0 ? _a : "") + ((_b = this.morphBytes) !== null && _b !== void 0 ? _b : "") + this.message;
        return util_1.Util.stdHash(toHash);
    }
}
exports.Announcement = Announcement;
class SpendModule {
    static createCoinCondition(puzzleHash, amount, memos = []) {
        return clvm_1.SExp.to([
            util_1.Util.sexp.bytesToAtom(condition_opcodes_1.ConditionOpcode.CREATE_COIN),
            util_1.Util.sexp.bytesToAtom(puzzleHash),
            util_1.Util.sexp.bytesToAtom(util_1.Util.coin.amountToBytes(amount)),
            ...(memos.length > 0 ? [clvm_1.SExp.to(memos.map(e => util_1.Util.sexp.bytesToAtom(e)))] : []),
        ]);
    }
    static reserveFeeCondition(fee) {
        return clvm_1.SExp.to([
            util_1.Util.sexp.bytesToAtom(condition_opcodes_1.ConditionOpcode.RESERVE_FEE),
            util_1.Util.sexp.bytesToAtom(util_1.Util.coin.amountToBytes(fee)),
        ]);
    }
    static createCoinAnnouncementCondition(message) {
        return clvm_1.SExp.to([
            util_1.Util.sexp.bytesToAtom(condition_opcodes_1.ConditionOpcode.CREATE_COIN_ANNOUNCEMENT),
            util_1.Util.sexp.bytesToAtom(message),
        ]);
    }
    static assertCoinAnnouncementCondition(announcementId) {
        return clvm_1.SExp.to([
            util_1.Util.sexp.bytesToAtom(condition_opcodes_1.ConditionOpcode.ASSERT_COIN_ANNOUNCEMENT),
            util_1.Util.sexp.bytesToAtom(announcementId),
        ]);
    }
    static createPuzzleAnnouncementCondition(message) {
        return clvm_1.SExp.to([
            util_1.Util.sexp.bytesToAtom(condition_opcodes_1.ConditionOpcode.CREATE_PUZZLE_ANNOUNCEMENT),
            util_1.Util.sexp.bytesToAtom(message),
        ]);
    }
    static assertPuzzleAnnouncementCondition(announcementId) {
        return clvm_1.SExp.to([
            util_1.Util.sexp.bytesToAtom(condition_opcodes_1.ConditionOpcode.ASSERT_PUZZLE_ANNOUNCEMENT),
            util_1.Util.sexp.bytesToAtom(announcementId),
        ]);
    }
    static bundleStandardCoins(standardCoins, firstCoinConditions, otherCoinsConditions) {
        const coinSpends = [];
        for (let index = 0; index < standardCoins.length; ++index) {
            const spendInfo = standardCoins[index].addConditionsToSolution(index === 0 ? firstCoinConditions : otherCoinsConditions);
            if (!spendInfo.isSpendable()) {
                throw new Error("StandardCoin not spendable");
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            coinSpends.push(spendInfo.spend());
        }
        return coinSpends;
    }
    // https://github.com/Chia-Network/chia-blockchain/blob/749162d9fead35d2beb2d34bdc7d90df4d5ec6d5/chia/wallet/cat_wallet/cat_utils.py#L88
    static bundleCATs(CATs, firstCoinConditions, otherCoinsConditions) {
        var _a, _b;
        const N = CATs.length;
        const deltas = [];
        for (let index = 0; index < CATs.length; ++index) {
            CATs[index] = CATs[index].addConditionsToInnerSolution(index === 0 ? firstCoinConditions : otherCoinsConditions);
            const c = CATs[index];
            if (c.TAILProgramHash !== CATs[0].TAILProgramHash) {
                throw new Error("CATs with different TAILs cannot be bundled together");
            }
            if (!c.innerPuzzle || !c.innerSolution || !c.amount)
                continue;
            const res = util_1.Util.sexp.conditionsDictForSolution(
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            c.innerPuzzle, 
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            c.innerSolution, util_1.Util.sexp.MAX_BLOCK_COST_CLVM);
            if (res[0]) {
                throw new Error("innerPuzzle returned an error");
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const conditionsDict = res[1];
            let total = bignumber_1.BigNumber.from((_a = c.extraDelta) !== null && _a !== void 0 ? _a : 0).mul(-1);
            for (const _ of ((_b = conditionsDict.get(condition_opcodes_1.ConditionOpcode.CREATE_COIN)) !== null && _b !== void 0 ? _b : [])) {
                if (_.vars[1] !== "8f") { // -113 in bytes
                    total = total.add(clvm_1.SExp.to(clvm_1.Bytes.from(_.vars[1], "hex")).as_bigint());
                }
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            deltas.push(bignumber_1.BigNumber.from(c.amount).sub(total));
        }
        if (deltas.length === 0 || !deltas.reduce((acc, x) => acc.add(x)).eq(0)) {
            throw new Error("input and output amounts don't match");
        }
        const subtotals = this.subtotalsForDeltas(deltas);
        const infosForNext = [];
        const infosForMe = [];
        const ids = [];
        for (const _ of CATs) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            infosForNext.push(_.toCoin());
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            infosForMe.push(_.toCoin());
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            ids.push(_.getId());
        }
        const coinSpends = [];
        for (let index = 0; index < N; ++index) {
            const prevIndex = (index - 1 + N) % N;
            const nextIndex = (index + 1) % N;
            const prevId = ids[prevIndex];
            const myInfo = infosForMe[index];
            const nextInfo = infosForNext[nextIndex];
            const spendInfo = CATs[index].copyWith({
                prevCoinId: prevId,
                coin: myInfo,
                nextCoin: nextInfo,
                prevSubtotal: subtotals[index],
            });
            if (!spendInfo.isSpendable()) {
                throw new Error("CAT not spendable");
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            coinSpends.push(spendInfo.spend());
        }
        return coinSpends;
    }
    // https://github.com/Chia-Network/chia-blockchain/blob/749162d9fead35d2beb2d34bdc7d90df4d5ec6d5/chia/wallet/cat_wallet/cat_utils.py#L63
    static subtotalsForDeltas(deltas) {
        const subtotals = [];
        let subtotal = bignumber_1.BigNumber.from(0);
        for (const delta of deltas) {
            subtotals.push(subtotal);
            subtotal = subtotal.add(delta);
        }
        // tweak the subtotals so the smallest value is 0
        const subtotalOffset = subtotals.reduce((acc, x) => acc.gt(x) ? x : acc);
        const newSubtotals = subtotals.map(e => e.sub(subtotalOffset));
        return newSubtotals;
    }
    static bundle(things, { standardCoinOutputConditions = [], CATOutputConditions = [], fee = 0 } = {}) {
        if (things.length === 0)
            return [];
        const coinSpends = [];
        const CATs = things.filter(e => e instanceof cat_1.CAT);
        const standardCoins = things.filter(e => e instanceof standard_coin_1.StandardCoin);
        let feeIncluded = false;
        const feeBN = bignumber_1.BigNumber.from(fee);
        const theHash = util_1.Util.stdHash(
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        things.map(c => c.getName()).join(""));
        const haveCATs = CATs.length > 0;
        const haveStandardCoins = standardCoins.length > 0;
        const ann = new Announcement(
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        haveCATs ? CATs[0].getId() : standardCoins[0].getId(), 
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        theHash, haveCATs ? "ca" : "");
        if (haveCATs) {
            const firstCoinConditions = CATOutputConditions;
            const otherCoinsConditions = [];
            if (haveStandardCoins) {
                firstCoinConditions.push(this.createCoinAnnouncementCondition(theHash));
            }
            if (feeBN.gt(0)) {
                firstCoinConditions.push(this.reserveFeeCondition(fee));
                feeIncluded = true;
            }
            const r = this.bundleCATs(CATs, firstCoinConditions, otherCoinsConditions);
            r.forEach(e => coinSpends.push(e));
        }
        if (haveStandardCoins) {
            const firstCoinConditions = standardCoinOutputConditions;
            const otherCoinsConditions = [];
            if (haveCATs) {
                firstCoinConditions.push(this.assertCoinAnnouncementCondition(ann.name()));
            }
            else {
                if (standardCoins.length > 1) {
                    firstCoinConditions.push(this.createCoinAnnouncementCondition(theHash));
                }
            }
            otherCoinsConditions.push(this.assertCoinAnnouncementCondition(ann.name()));
            if (feeBN.gt(0) && !feeIncluded) {
                firstCoinConditions.push(this.reserveFeeCondition(fee));
            }
            const r = this.bundleStandardCoins(standardCoins, firstCoinConditions, otherCoinsConditions);
            r.forEach(e => coinSpends.push(e));
        }
        return coinSpends;
    }
    static merge(things) {
        const { AugSchemeMPL, G2Element } = (0, clvm_1.getBLSModule)();
        const sb = new spend_bundle_1.SpendBundle();
        sb.coinSpends = things
            .map(t => t instanceof spend_bundle_1.SpendBundle ? t.coinSpends : (t instanceof coin_spend_1.CoinSpend ? [t,] : t))
            .reduce((acc, x) => [...acc, ...x]);
        const sigs = [];
        for (const t of things) {
            if (!(t instanceof spend_bundle_1.SpendBundle))
                continue;
            const sigStr = t.aggregatedSignature;
            sigs.push(G2Element.from_bytes(Buffer.from(sigStr, "hex")));
        }
        sb.aggregatedSignature = Buffer.from(AugSchemeMPL.aggregate(sigs).serialize()).toString("hex");
        return sb;
    }
    // https://github.com/Chia-Network/chia-blockchain/blob/280f462071e5fe1b7883cefac73712789e22b664/chia/wallet/puzzles/singleton_top_layer_v1_1.py#L179
    static singletonLaunchConditionsAndCoinSol(coin, innerPuzzle, amount, comment = []) {
        if (bignumber_1.BigNumber.from(amount).mod(2).eq(0)) {
            throw new Error("Coin amount cannot be even. Subtract one mojo.");
        }
        const launcherCoin = this.generateLauncherCoin(coin, amount);
        const launcherCoinId = util_1.Util.coin.getId(launcherCoin);
        const curriedSingleton = util_1.Util.sexp.singletonPuzzle(launcherCoinId, innerPuzzle);
        const launcherSolution = util_1.Util.sexp.singletonLauncherSolution(util_1.Util.sexp.sha256tree(curriedSingleton), amount, comment);
        const createLauncherAnnouncement = this.createCoinCondition(util_1.Util.sexp.SINGLETON_LAUNCHER_PROGRAM_HASH, amount);
        const assertLauncherAnnouncement = this.assertCoinAnnouncementCondition(util_1.Util.stdHash(launcherCoinId + util_1.Util.sexp.sha256tree(launcherSolution)));
        const launcherCs = new coin_spend_1.CoinSpend();
        launcherCs.coin = launcherCoin;
        launcherCs.puzzleReveal = util_1.Util.sexp.SINGLETON_LAUNCHER_PROGRAM;
        launcherCs.solution = launcherSolution;
        return [
            [createLauncherAnnouncement, assertLauncherAnnouncement],
            launcherCs
        ];
    }
    // https://github.com/Chia-Network/chia-blockchain/blob/280f462071e5fe1b7883cefac73712789e22b664/chia/wallet/puzzles/singleton_top_layer_v1_1.py#L169
    static generateLauncherCoin(coin, amount) {
        const c = new provider_types_1.Coin();
        c.parentCoinInfo = util_1.Util.coin.getId(coin);
        c.puzzleHash = util_1.Util.sexp.SINGLETON_LAUNCHER_PROGRAM_HASH;
        c.amount = amount;
        return c;
    }
    static launchSingleton(standardCoins, innerPuzzle, amount, fee = 0, additionalInitialCoinConditions = [], comment = []) {
        const firstCoin = standardCoins[0].toCoin();
        if (firstCoin === null) {
            throw new Error("Coin that is supposed to launch the singleton launcher does not have enough info.");
        }
        const [conditions, cs] = this.singletonLaunchConditionsAndCoinSol(firstCoin, innerPuzzle, amount, comment);
        const otherCoinSpends = this.bundle(standardCoins, {
            fee,
            standardCoinOutputConditions: [
                ...conditions,
                ...additionalInitialCoinConditions
            ]
        });
        const launcherId = util_1.Util.coin.getId(cs.coin);
        const lineageProof = {
            amount: cs.coin.amount,
            parentName: launcherId
        };
        const singleton = new singleton_1.Singleton({
            amount: cs.coin.amount,
            parentCoinInfo: launcherId,
            launcherId,
            innerPuzzle,
            lineageProof
        });
        return [
            singleton,
            [...otherCoinSpends, cs]
        ];
    }
    static useP2SingletonCoinsConditionsAndCoinSol(singletonLauncherId, singletonInnerPuzzleHash, coins) {
        const coinSpends = [];
        const singletonOutputConditions = [];
        const p2Puzzle = util_1.Util.sexp.payToSingletonPuzzle(singletonLauncherId);
        for (const coin of coins) {
            const coinId = util_1.Util.coin.getId(coin);
            const coinAnn = new Announcement(coinId, "24"); // 0x24 = $
            singletonOutputConditions.push(this.assertCoinAnnouncementCondition(coinAnn.name()));
            singletonOutputConditions.push(this.createPuzzleAnnouncementCondition(coinId));
            const cs = new coin_spend_1.CoinSpend();
            cs.coin = coin;
            cs.puzzleReveal = p2Puzzle;
            cs.solution = util_1.Util.sexp.payToSingletonSolution(singletonInnerPuzzleHash, coinId);
            coinSpends.push(cs);
        }
        return [singletonOutputConditions, coinSpends];
    }
}
exports.SpendModule = SpendModule;
SpendModule.Announcement = Announcement;
//# sourceMappingURL=index.js.map