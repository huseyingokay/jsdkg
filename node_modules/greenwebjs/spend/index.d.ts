import { BigNumber } from "@ethersproject/bignumber";
import { SExp } from "clvm";
import { CAT } from "../cat";
import { Singleton } from "../singleton";
import { StandardCoin } from "../standard_coin";
import { uint } from "../util/serializer/basic_types";
import { CoinSpend } from "../util/serializer/types/coin_spend";
import { SpendBundle } from "../util/serializer/types/spend_bundle";
import { bytes, Coin } from "../xch/providers/provider_types";
export declare class Announcement {
    originInfo?: bytes;
    message?: bytes;
    morphBytes?: bytes;
    constructor(originInfo?: bytes, message?: bytes, morphBytes?: bytes);
    name(): bytes;
}
export declare type BundleArgs = {
    standardCoinOutputConditions?: SExp[];
    CATOutputConditions?: SExp[];
    fee?: uint;
};
export declare class SpendModule {
    static Announcement: typeof Announcement;
    static createCoinCondition(puzzleHash: bytes, amount: uint, memos?: bytes[]): SExp;
    static reserveFeeCondition(fee: uint): SExp;
    static createCoinAnnouncementCondition(message: bytes): SExp;
    static assertCoinAnnouncementCondition(announcementId: bytes): SExp;
    static createPuzzleAnnouncementCondition(message: bytes): SExp;
    static assertPuzzleAnnouncementCondition(announcementId: bytes): SExp;
    static bundleStandardCoins(standardCoins: StandardCoin[], firstCoinConditions: SExp[], otherCoinsConditions: SExp[]): CoinSpend[];
    static bundleCATs(CATs: CAT[], firstCoinConditions: SExp[], otherCoinsConditions: SExp[]): CoinSpend[];
    static subtotalsForDeltas(deltas: BigNumber[]): BigNumber[];
    static bundle(things: Array<CAT | StandardCoin>, { standardCoinOutputConditions, CATOutputConditions, fee }?: BundleArgs): CoinSpend[];
    static merge(things: Array<SpendBundle | CoinSpend | CoinSpend[]>): SpendBundle;
    static singletonLaunchConditionsAndCoinSol(coin: Coin, innerPuzzle: SExp, amount: uint, comment?: Array<[string, string]>): [SExp[], CoinSpend];
    private static generateLauncherCoin;
    static launchSingleton(standardCoins: StandardCoin[], innerPuzzle: SExp, amount: uint, fee?: uint, additionalInitialCoinConditions?: SExp[], comment?: Array<[string, string]>): [Singleton, CoinSpend[]];
    static useP2SingletonCoinsConditionsAndCoinSol(singletonLauncherId: bytes, singletonInnerPuzzleHash: bytes, coins: Coin[]): [SExp[], CoinSpend[]];
}
