"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Singleton = void 0;
const bignumber_1 = require("@ethersproject/bignumber");
const clvm_1 = require("clvm");
const smart_coin_1 = require("./smart_coin");
const util_1 = require("./util");
class Singleton extends smart_coin_1.SmartCoin {
    constructor({ parentCoinInfo = null, puzzleHash = null, amount = null, coin = null, launcherId = null, innerPuzzle = null, lineageProof = null, innerSolution = null, } = {}) {
        var _a, _b;
        super({
            parentCoinInfo, puzzleHash, amount, coin
        });
        this.launcherId = null;
        this.innerPuzzle = null;
        this.innerPuzzleHash = null;
        this.lineageProof = null;
        this.innerSolution = null;
        this.launcherId = util_1.Util.dehexlify(launcherId);
        this.innerPuzzle = innerPuzzle;
        this.innerSolution = innerSolution;
        if (lineageProof !== null && lineageProof !== undefined) {
            this.lineageProof = {
                amount: lineageProof.amount ? bignumber_1.BigNumber.from(lineageProof.amount) : null,
                parentName: util_1.Util.dehexlify((_a = lineageProof.parentName) !== null && _a !== void 0 ? _a : null),
                innerPuzzleHash: util_1.Util.dehexlify((_b = lineageProof.innerPuzzleHash) !== null && _b !== void 0 ? _b : null),
            };
        }
        this.calculateInnerPuzzleHash();
        this.constructPuzzle();
        this.constructSolution();
    }
    calculateInnerPuzzleHash() {
        if (this.innerPuzzle === null)
            return;
        this.innerPuzzleHash = util_1.Util.sexp.sha256tree(this.innerPuzzle);
    }
    constructPuzzle() {
        if (this.launcherId === null || this.innerPuzzle === null)
            return;
        this.puzzle = util_1.Util.sexp.singletonPuzzle(this.launcherId, this.innerPuzzle);
        this.calculatePuzzleHash();
    }
    lineageProofToSExpForSolution() {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const lp = this.lineageProof;
        return clvm_1.SExp.to([
            clvm_1.Bytes.from(lp.parentName, "hex"),
            ...(lp.innerPuzzleHash === null ? [] : [
                clvm_1.Bytes.from(lp.innerPuzzleHash, "hex"),
            ]),
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            clvm_1.Bytes.from(util_1.Util.coin.amountToBytes(lp.amount), "hex"),
        ]);
    }
    constructSolution() {
        if (this.lineageProof === null ||
            this.amount === null ||
            this.innerSolution === null ||
            this.lineageProof.parentName === null ||
            this.lineageProof.amount === null)
            return;
        this.solution = this.solution = util_1.Util.sexp.singletonSolution(this.lineageProofToSExpForSolution(), this.amount, this.innerSolution);
    }
    copyWith({ parentCoinInfo = null, puzzleHash = null, amount = null, coin = null, launcherId = null, innerPuzzle = null, lineageProof = null, innerSolution = null, }) {
        return new Singleton({
            parentCoinInfo: parentCoinInfo !== null && parentCoinInfo !== void 0 ? parentCoinInfo : this.parentCoinInfo,
            puzzleHash: puzzleHash !== null && puzzleHash !== void 0 ? puzzleHash : this.puzzleHash,
            amount: amount !== null && amount !== void 0 ? amount : this.amount,
            coin: coin,
            launcherId: launcherId !== null && launcherId !== void 0 ? launcherId : this.launcherId,
            innerPuzzle: innerPuzzle !== null && innerPuzzle !== void 0 ? innerPuzzle : this.innerPuzzle,
            lineageProof: lineageProof !== null && lineageProof !== void 0 ? lineageProof : this.lineageProof,
            innerSolution: innerSolution !== null && innerSolution !== void 0 ? innerSolution : this.innerSolution,
        });
    }
    withParentCoinInfo(parentCoinInfo) {
        return this.copyWith({
            parentCoinInfo,
        });
    }
    withPuzzleHash(puzzleHash) {
        return this.copyWith({
            puzzleHash,
        });
    }
    withAmount(amount) {
        return this.copyWith({
            amount,
        });
    }
    withLauncherId(launcherId) {
        return this.copyWith({
            launcherId,
        });
    }
    withInnerPuzzle(innerPuzzle) {
        return this.copyWith({
            innerPuzzle,
        });
    }
    withLineageProof(lineageProof) {
        return this.copyWith({
            lineageProof,
        });
    }
    withInnerSolution(innerSolution) {
        return this.copyWith({
            innerSolution,
        });
    }
    getPayToPuzzleHash() {
        if (this.launcherId === null)
            return null;
        return util_1.Util.sexp.sha256tree(util_1.Util.sexp.payToSingletonPuzzle(this.launcherId));
    }
    getPayToAddress() {
        const ph = this.getPayToPuzzleHash();
        if (ph === null)
            return null;
        return util_1.Util.address.puzzleHashToAddress(ph);
    }
}
exports.Singleton = Singleton;
//# sourceMappingURL=singleton.js.map