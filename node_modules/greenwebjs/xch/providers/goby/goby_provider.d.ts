import { BigNumber } from "@ethersproject/bignumber";
import { Network } from "../../../util/network";
import { SpendBundle } from "../../../util/serializer/types/spend_bundle";
import { Provider } from "../provider";
import { getBalanceArgs, subscribeToPuzzleHashUpdatesArgs, subscribeToCoinUpdatesArgs, getPuzzleSolutionArgs, getCoinChildrenArgs, getBlockHeaderArgs, getBlocksHeadersArgs, getCoinRemovalsArgs, getCoinAdditionsArgs, acceptOfferArgs, transferArgs, transferCATArgs, subscribeToAddressChangesArgs, signCoinSpendsArgs, changeNetworkArgs, pushSpendBundleArgs } from "../provider_args";
import { Optional, PuzzleSolution, CoinState, BlockHeader, Coin } from "../provider_types";
declare global {
    interface Window {
        chia: any;
    }
}
export declare class GobyProvider implements Provider {
    private _address;
    private _network;
    private _callbacks;
    private _chiaOverwrite;
    private _callbacksInitialized;
    constructor(tryNonInteractiveConnect?: boolean, _chiaOverwrite?: any);
    private _getChia;
    private _isGobyInstalled;
    private _changeAddress;
    connect(): Promise<void>;
    close(): Promise<void>;
    getNetworkId(): Network;
    isConnected(): boolean;
    private _doesNotImplementError;
    getBlockNumber(): Promise<Optional<number>>;
    getBalance(args: getBalanceArgs): Promise<Optional<BigNumber>>;
    subscribeToPuzzleHashUpdates(args: subscribeToPuzzleHashUpdatesArgs): void;
    subscribeToCoinUpdates(args: subscribeToCoinUpdatesArgs): void;
    getPuzzleSolution(args: getPuzzleSolutionArgs): Promise<Optional<PuzzleSolution>>;
    getCoinChildren(args: getCoinChildrenArgs): Promise<CoinState[]>;
    getBlockHeader(args: getBlockHeaderArgs): Promise<Optional<BlockHeader>>;
    getBlocksHeaders(args: getBlocksHeadersArgs): Promise<Optional<BlockHeader[]>>;
    getCoinRemovals(args: getCoinRemovalsArgs): Promise<Optional<Coin[]>>;
    getCoinAdditions(args: getCoinAdditionsArgs): Promise<Optional<Coin[]>>;
    pushSpendBundle({ spendBundle }: pushSpendBundleArgs): Promise<boolean>;
    getAddress(): Promise<string>;
    transfer({ to, value, fee }: transferArgs): Promise<Optional<SpendBundle>>;
    transferCAT({ to, value, assetId, fee }: transferCATArgs): Promise<Optional<SpendBundle>>;
    acceptOffer({ offer, fee }: acceptOfferArgs): Promise<Optional<SpendBundle>>;
    subscribeToAddressChanges({ callback }: subscribeToAddressChangesArgs): void;
    signCoinSpends(args: signCoinSpendsArgs): Promise<Optional<SpendBundle>>;
    changeNetwork({ network }: changeNetworkArgs): Promise<boolean>;
}
