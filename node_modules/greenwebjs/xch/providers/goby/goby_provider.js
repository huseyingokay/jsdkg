"use strict";
/*
Special thanks to donate.goby.app and offerpool.io
*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GobyProvider = void 0;
const bignumber_1 = require("@ethersproject/bignumber");
const util_1 = require("../../../util");
const network_1 = require("../../../util/network");
class GobyProvider {
    constructor(tryNonInteractiveConnect = true, _chiaOverwrite = null) {
        this._address = "";
        this._network = network_1.Network.mainnet;
        this._callbacks = [];
        this._chiaOverwrite = null;
        this._callbacksInitialized = false;
        this._chiaOverwrite = _chiaOverwrite; // used for testing purposes
        if (!tryNonInteractiveConnect || !this._isGobyInstalled()) {
            return;
        }
        this._getChia().request({ method: "accounts" }).then((accounts) => this._changeAddress(accounts === null || accounts.length === 0 ? "" : accounts[0]));
    }
    _getChia() {
        if (this._chiaOverwrite === null)
            return window.chia;
        return this._chiaOverwrite;
    }
    // https://github.com/offerpool/offerpool/commit/06178554cb35d985def1f77ebf56fa110bafed37#diff-ebb1516e535afb1a750fde696b67201f7e1afb997d33d8462f41cca6c670d36d
    _isGobyInstalled() {
        try {
            const chia = this._getChia();
            return Boolean(chia && chia.isGoby);
        }
        catch (_) {
            return false;
        }
    }
    _changeAddress(newAddress) {
        if (this._address === "" && newAddress !== "" && !this._callbacksInitialized) {
            this._callbacksInitialized = true;
            this._getChia().on("accountsChanged", (accounts) => {
                var _a;
                this._changeAddress((_a = accounts === null || accounts === void 0 ? void 0 : accounts[0]) !== null && _a !== void 0 ? _a : "");
            });
            this._getChia().on("chainChanged", (chainId) => {
                if (chainId === "0x01") {
                    this._network = network_1.Network.mainnet;
                }
                else {
                    this._network = network_1.Network.testnet10;
                }
            });
        }
        this._address = newAddress;
        for (let i = 0; i < this._callbacks.length; ++i) {
            this._callbacks[i](newAddress);
        }
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._isGobyInstalled() || this.isConnected()) {
                return;
            }
            let accounts;
            try {
                accounts = yield this._getChia().request({ method: "requestAccounts" });
            }
            catch (_) {
                accounts = [];
            }
            this._changeAddress(accounts === null || accounts.length === 0 ? "" : accounts[0]);
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isConnected()) {
                return;
            }
            this._changeAddress("");
        });
    }
    getNetworkId() {
        if (!this.isConnected()) {
            return network_1.Network.mainnet;
        }
        return this._network;
    }
    isConnected() {
        return this._address !== "";
    }
    _doesNotImplementError() {
        throw new Error("GobyProvider does not implement this method.");
    }
    getBlockNumber() {
        return __awaiter(this, void 0, void 0, function* () { return this._doesNotImplementError(); });
    }
    getBalance(args) {
        return __awaiter(this, void 0, void 0, function* () { return this._doesNotImplementError(); });
    }
    subscribeToPuzzleHashUpdates(args) { return this._doesNotImplementError(); }
    subscribeToCoinUpdates(args) { return this._doesNotImplementError(); }
    getPuzzleSolution(args) {
        return __awaiter(this, void 0, void 0, function* () { return this._doesNotImplementError(); });
    }
    getCoinChildren(args) {
        return __awaiter(this, void 0, void 0, function* () { return this._doesNotImplementError(); });
    }
    getBlockHeader(args) {
        return __awaiter(this, void 0, void 0, function* () { return this._doesNotImplementError(); });
    }
    getBlocksHeaders(args) {
        return __awaiter(this, void 0, void 0, function* () { return this._doesNotImplementError(); });
    }
    getCoinRemovals(args) {
        return __awaiter(this, void 0, void 0, function* () { return this._doesNotImplementError(); });
    }
    getCoinAdditions(args) {
        return __awaiter(this, void 0, void 0, function* () { return this._doesNotImplementError(); });
    }
    pushSpendBundle({ spendBundle }) {
        return __awaiter(this, void 0, void 0, function* () {
            // Seems like this feature isn't live yet
            return this._doesNotImplementError();
            // try {
            //     const res = await this._getChia().request({
            //         method: "pushTx",
            //         params: {
            //             spendBundle,
            //         }
            //     });
            //     if(["success", "pending"].includes(res.status)) {
            //         return true;
            //     }
            //     return false;
            // } catch(_) {
            //     return false;
            // }
        });
    }
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            return this._address;
        });
    }
    transfer({ to, value, fee = 0 }) {
        // you did not see this
        // kapische?
        return this.transferCAT({ to, value, fee, assetId: "" });
    }
    transferCAT({ to, value, assetId, fee = 0 }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isConnected()) {
                return null;
            }
            try {
                value = bignumber_1.BigNumber.from(value);
                fee = bignumber_1.BigNumber.from(fee);
                const resp = yield this._getChia().request({
                    method: "transfer",
                    params: {
                        to,
                        amount: value.toString(),
                        memos: "",
                        assetId,
                        fee: fee.toString()
                    }
                });
                return util_1.Util.goby.parseGobySpendBundle(resp["transaction"]);
            }
            catch (_) {
                return null;
            }
        });
    }
    acceptOffer({ offer, fee = 0 }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isConnected()) {
                return null;
            }
            try {
                fee = bignumber_1.BigNumber.from(fee);
                const resp = yield this._getChia().request({
                    method: "takeOffer",
                    params: {
                        offer,
                        fee: fee.toString()
                    }
                });
                return util_1.Util.goby.parseGobySpendBundle(resp["transaction"]);
            }
            catch (_) {
                return null;
            }
        });
    }
    subscribeToAddressChanges({ callback }) {
        this._callbacks.push(callback);
        callback(this._address);
    }
    signCoinSpends(args) {
        return __awaiter(this, void 0, void 0, function* () {
            // hopefully soon
            return this._doesNotImplementError();
        });
    }
    changeNetwork({ network }) {
        return __awaiter(this, void 0, void 0, function* () {
            let chainId = "";
            switch (network) {
                case network_1.Network.mainnet:
                    chainId = "0x01";
                    break;
                case network_1.Network.testnet10:
                    chainId = "0x02";
                    break;
                default:
                    return false;
            }
            try {
                yield this._getChia().request({
                    method: "walletSwitchChain",
                    params: {
                        chainId,
                    }
                });
            }
            catch (_) {
                return false;
            }
            return true;
        });
    }
}
exports.GobyProvider = GobyProvider;
//# sourceMappingURL=goby_provider.js.map