"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrivateKeyProvider = void 0;
const clvm_1 = require("clvm");
const spend_bundle_1 = require("../../../util/serializer/types/spend_bundle");
const util_1 = require("../../../util");
const network_1 = require("../../../util/network");
const __1 = require("../../..");
class PrivateKeyProvider {
    constructor(privateKey, network = network_1.Network.mainnet) {
        const key = util_1.Util.address.validateHashString(privateKey);
        if (key === "") {
            throw new Error("Invalid private key.");
        }
        this.privateKey = key;
        this.connected = false;
        this.network = network;
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, clvm_1.initialize)();
            this.connected = true;
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            this.connected = false;
        });
    }
    getNetworkId() {
        return this.network;
    }
    isConnected() {
        return this.connected;
    }
    _doesNotImplementError() {
        throw new Error("PrivateKeyProvider does not implement this method.");
    }
    getBlockNumber() {
        return __awaiter(this, void 0, void 0, function* () { return this._doesNotImplementError(); });
    }
    getBalance(args) {
        return __awaiter(this, void 0, void 0, function* () { return this._doesNotImplementError(); });
    }
    subscribeToPuzzleHashUpdates(args) { return this._doesNotImplementError(); }
    subscribeToCoinUpdates(args) { return this._doesNotImplementError(); }
    getPuzzleSolution(args) {
        return __awaiter(this, void 0, void 0, function* () { return this._doesNotImplementError(); });
    }
    getCoinChildren(args) {
        return __awaiter(this, void 0, void 0, function* () { return this._doesNotImplementError(); });
    }
    getBlockHeader(args) {
        return __awaiter(this, void 0, void 0, function* () { return this._doesNotImplementError(); });
    }
    getBlocksHeaders(args) {
        return __awaiter(this, void 0, void 0, function* () { return this._doesNotImplementError(); });
    }
    getCoinRemovals(args) {
        return __awaiter(this, void 0, void 0, function* () { return this._doesNotImplementError(); });
    }
    getCoinAdditions(args) {
        return __awaiter(this, void 0, void 0, function* () { return this._doesNotImplementError(); });
    }
    pushSpendBundle(args) {
        return __awaiter(this, void 0, void 0, function* () { return this._doesNotImplementError(); });
    }
    getAddress() {
        return __awaiter(this, void 0, void 0, function* () { return this._doesNotImplementError(); });
    }
    transfer(args) {
        return __awaiter(this, void 0, void 0, function* () { return this._doesNotImplementError(); });
    }
    transferCAT(args) {
        return __awaiter(this, void 0, void 0, function* () { return this._doesNotImplementError(); });
    }
    acceptOffer(args) {
        return __awaiter(this, void 0, void 0, function* () { return this._doesNotImplementError(); });
    }
    subscribeToAddressChanges(args) { return this._doesNotImplementError(); }
    signCoinSpends({ coinSpends }, customGenesisChallenge = null) {
        return __awaiter(this, void 0, void 0, function* () {
            const networkData = customGenesisChallenge !== null && customGenesisChallenge !== void 0 ? customGenesisChallenge : util_1.Util.network.getGenesisChallenge(this.network);
            const { AugSchemeMPL } = (0, clvm_1.getBLSModule)();
            const emptySig = AugSchemeMPL.aggregate([]);
            const signatures = [
                AugSchemeMPL.aggregate([]),
            ];
            const sk = util_1.Util.key.hexToPrivateKey(this.privateKey);
            const publicKey = Buffer.from(sk.get_g1().serialize()).toString("hex");
            for (let i = 0; i < coinSpends.length; i++) {
                const coinSpend = coinSpends[i];
                const [, conditions,] = __1.util.sexp.conditionsDictForSolution(coinSpend.puzzleReveal, coinSpend.solution, util_1.Util.sexp.MAX_BLOCK_COST_CLVM);
                if (conditions !== null) {
                    const pk_msg_things = __1.util.sexp.pkmPairsForConditionsDict(conditions, util_1.Util.coin.getId(coinSpend.coin), networkData);
                    for (const [pk, msg] of pk_msg_things) {
                        if (pk !== publicKey) {
                            continue;
                        }
                        const sig = AugSchemeMPL.sign(sk, Buffer.from(msg, "hex"));
                        signatures.push(sig);
                    }
                }
            }
            const sb = new spend_bundle_1.SpendBundle();
            sb.coinSpends = coinSpends;
            sb.aggregatedSignature = Buffer.from(AugSchemeMPL.aggregate(signatures).serialize()).toString("hex");
            return sb;
        });
    }
    changeNetwork(args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (util_1.Util.network.networks.includes(args.network)) {
                this.network = args.network;
                return true;
            }
            return false;
        });
    }
}
exports.PrivateKeyProvider = PrivateKeyProvider;
//# sourceMappingURL=private_key_provider.js.map