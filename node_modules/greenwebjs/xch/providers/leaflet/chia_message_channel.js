"use strict";
// https://github.com/freddiecoleman/chia-network-scanner/blob/main/MessageChannel.ts
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChiaMessageChannel = exports._ensureWebSocket = void 0;
const outbound_message_1 = require("../../../util/serializer/types/outbound_message");
const protocol_message_types_1 = require("../../../util/serializer/types/protocol_message_types");
const shared_protocol_1 = require("../../../util/serializer/types/shared_protocol");
const software_version_1 = require("../../../util/software_version");
function _ensureWebSocket() {
    try {
        if (typeof document === "undefined") {
            // server: overwrite WebSocket
            global.WebSocket = require("ws");
        }
        // eslint-disable-next-line no-empty
    }
    catch (_) { }
}
exports._ensureWebSocket = _ensureWebSocket;
_ensureWebSocket();
class ChiaMessageChannel {
    constructor({ host, port, apiKey, onMessage, network, webSocketCreateFunc }) {
        this.inboundDataBuffer = Buffer.from([]);
        this.port = port;
        this.onMessage = onMessage;
        if (host.includes(":") && host[0] !== "[") { // IPv6
            host = "[" + host + "]";
        }
        this.host = host;
        this.network = network;
        this.apiKey = apiKey;
        this.webSocketCreateFunc = webSocketCreateFunc;
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            const url = "wss://" + this.host + ":" + this.port.toString() + "/" + this.apiKey + "/ws";
            if (this.isConnected()) {
                return;
            }
            this.ws = this.webSocketCreateFunc(url);
            return new Promise((resolve) => {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.ws.onmessage = (message) => __awaiter(this, void 0, void 0, function* () {
                    let isBlob;
                    try {
                        isBlob = message.data instanceof Blob;
                    }
                    catch (_) {
                        isBlob = false;
                    }
                    const msg = message.data instanceof Array ? Buffer.concat(message.data) :
                        isBlob ? Buffer.from(yield message.data.arrayBuffer()) :
                            Buffer.from(message.data);
                    this.messageHandler(msg);
                });
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.ws.onopen = () => {
                    this.onConnected();
                    resolve();
                };
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.ws.onerror = () => {
                    this.close();
                    resolve();
                };
            });
        });
    }
    sendMessage(message) {
        var _a;
        (_a = this.ws) === null || _a === void 0 ? void 0 : _a.send(message);
    }
    close() {
        var _a;
        (_a = this.ws) === null || _a === void 0 ? void 0 : _a.close();
        this.ws = undefined;
    }
    isConnected() {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this.ws !== undefined && this.ws.readyState === WebSocket.OPEN;
    }
    messageHandler(data) {
        this.inboundDataBuffer = Buffer.concat([this.inboundDataBuffer, data]);
        // Buffer is big enough to contain the length
        if (this.inboundDataBuffer.byteLength < 5) {
            return;
        }
        do {
            const haveMessageId = this.inboundDataBuffer.readUInt8(1);
            const messageLength = haveMessageId !== 0 ?
                this.inboundDataBuffer.readUInt32BE(4) :
                this.inboundDataBuffer.readUInt32BE(2);
            const realMessageLength = messageLength + (haveMessageId ? 8 : 6);
            const canConsumeMessage = this.inboundDataBuffer.byteLength >= realMessageLength;
            if (canConsumeMessage) {
                const message = this.inboundDataBuffer.slice(0, realMessageLength);
                this.inboundDataBuffer = this.inboundDataBuffer.slice(realMessageLength);
                this.onMessage(message);
            }
            else {
                break;
            }
        } while (this.inboundDataBuffer.byteLength >= 5);
        // note: The original file had a 'buffer overflow protection' thingy here
        // I don't think I understood it
        // If you do and think it's needed, please do reach out
    }
    onConnected() {
        const handshake = new shared_protocol_1.Handshake();
        handshake.networkId = this.network;
        handshake.protocolVersion = shared_protocol_1.PROTOCOL_VERSION;
        handshake.softwareVersion = (0, software_version_1.getSoftwareVersion)();
        handshake.serverPort = this.port;
        handshake.nodeType = outbound_message_1.NodeType.WALLET;
        handshake.capabilities = [[shared_protocol_1.Capability.BASE, "1"],];
        const hanshakeMsg = (0, outbound_message_1.makeMsg)(protocol_message_types_1.ProtocolMessageTypes.handshake, handshake);
        this.sendMessage(hanshakeMsg);
    }
}
exports.ChiaMessageChannel = ChiaMessageChannel;
//# sourceMappingURL=chia_message_channel.js.map