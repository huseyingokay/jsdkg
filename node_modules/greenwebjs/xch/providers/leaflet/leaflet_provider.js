"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LeafletProvider = void 0;
const providerTypes = __importStar(require("../provider_types"));
const outbound_message_1 = require("../../../util/serializer/types/outbound_message");
const serializer_1 = require("../../../util/serializer/serializer");
const protocol_message_types_1 = require("../../../util/serializer/types/protocol_message_types");
const wallet_protocol_1 = require("../../../util/serializer/types/wallet_protocol");
const address_1 = require("../../../util/address");
const bignumber_1 = require("@ethersproject/bignumber");
const message_manager_1 = require("./message_manager");
const chia_message_channel_1 = require("./chia_message_channel");
const util_1 = require("../../../util");
const network_1 = require("../../../util/network");
const addressUtil = new address_1.AddressUtil();
class LeafletProvider {
    constructor(host, apiKey, port = 18444, network = network_1.Network.mainnet, webSocketCreateFunc = (url) => new WebSocket(url)) {
        this.blockNumber = null;
        this.messageManager = new message_manager_1.MessageManager((onMessage) => __awaiter(this, void 0, void 0, function* () {
            return new chia_message_channel_1.ChiaMessageChannel({
                host, port, apiKey, onMessage, network, webSocketCreateFunc
            });
        }));
        this.network = network;
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.messageManager.initialize();
            this.messageManager.registerFilter({
                consumeMessage: (msg) => {
                    if (bignumber_1.BigNumber.from(msg.type).toNumber() !== protocol_message_types_1.ProtocolMessageTypes.new_peak_wallet) {
                        return false;
                    }
                    const pckt = serializer_1.Serializer.deserialize(wallet_protocol_1.NewPeakWallet, Buffer.from(msg.data, "hex"));
                    this.blockNumber = bignumber_1.BigNumber.from(pckt.height).toNumber();
                    return true;
                },
                deleteAfterFirstMessageConsumed: false,
                expectedMaxRensponseWait: 120 * 1000
            });
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.messageManager.close();
        });
    }
    getNetworkId() {
        return this.network;
    }
    isConnected() {
        return this.messageManager.open;
    }
    getBlockNumber() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.blockNumber;
        });
    }
    getBalance({ address, puzzleHash, minHeight = 1 }) {
        return __awaiter(this, void 0, void 0, function* () {
            let puzHash;
            // get puzHash: Buffer from address / puzzle hash
            if (address !== undefined) {
                puzHash = addressUtil.addressToPuzzleHash(address);
                if (puzHash.length === 0) {
                    return null;
                }
            }
            else if (puzzleHash !== undefined) {
                puzHash = addressUtil.validateHashString(puzzleHash);
            }
            else
                return null;
            // Register for updates
            const pckt = new wallet_protocol_1.RegisterForPhUpdates();
            pckt.minHeight = minHeight;
            pckt.puzzleHashes = [puzHash];
            let coinStates = [];
            const msgToSend = (0, outbound_message_1.makeMsg)(protocol_message_types_1.ProtocolMessageTypes.register_interest_in_puzzle_hash, pckt);
            yield this.messageManager.registerFilter({
                messageToSend: msgToSend,
                consumeMessage: (msg) => {
                    if (bignumber_1.BigNumber.from(msg.type).toNumber() !== protocol_message_types_1.ProtocolMessageTypes.respond_to_ph_update) {
                        return false;
                    }
                    const rPckt = serializer_1.Serializer.deserialize(wallet_protocol_1.RespondToPhUpdates, msg.data);
                    if (!rPckt.puzzleHashes.includes(puzHash) ||
                        !bignumber_1.BigNumber.from(rPckt.minHeight).eq(minHeight)) {
                        return false;
                    }
                    coinStates = rPckt.coinStates.filter((cs) => cs.coin.puzzleHash === puzHash);
                    return true;
                },
            });
            // filter received list of puzzle hashes and compute balance
            const unspentCoins = coinStates.filter((coinState) => coinState.spentHeight == null);
            let balance = bignumber_1.BigNumber.from(0);
            for (let i = 0; i < unspentCoins.length; ++i) {
                balance = balance.add(unspentCoins[i].coin.amount);
            }
            return balance;
        });
    }
    subscribeToPuzzleHashUpdates({ puzzleHash, callback, minHeight = 1 }) {
        puzzleHash = addressUtil.validateHashString(puzzleHash);
        if (puzzleHash.length === 0)
            return;
        // Register for updates
        const pckt = new wallet_protocol_1.RegisterForPhUpdates();
        pckt.minHeight = minHeight;
        pckt.puzzleHashes = [
            puzzleHash,
        ];
        const msgToSend = (0, outbound_message_1.makeMsg)(protocol_message_types_1.ProtocolMessageTypes.register_interest_in_puzzle_hash, pckt);
        this.messageManager.registerFilter({
            messageToSend: msgToSend,
            consumeMessage: (msg) => {
                if (bignumber_1.BigNumber.from(msg.type).toNumber() !== protocol_message_types_1.ProtocolMessageTypes.respond_to_ph_update) {
                    return false;
                }
                const rPckt = serializer_1.Serializer.deserialize(wallet_protocol_1.RespondToPhUpdates, msg.data);
                if (!rPckt.puzzleHashes.includes(puzzleHash) ||
                    !bignumber_1.BigNumber.from(rPckt.minHeight).eq(minHeight)) {
                    return false;
                }
                const coins = rPckt.coinStates.filter((cs) => cs.coin.puzzleHash === puzzleHash);
                callback(coins);
                return true;
            },
            deleteAfterFirstMessageConsumed: false,
            expectedMaxRensponseWait: 0
        });
    }
    subscribeToCoinUpdates({ coinId, callback, minHeight = 1 }) {
        coinId = addressUtil.validateHashString(coinId);
        if (coinId.length === 0)
            return;
        // Register for updates
        const pckt = new wallet_protocol_1.RegisterForCoinUpdates();
        pckt.minHeight = minHeight;
        pckt.coinIds = [
            coinId,
        ];
        const msgToSend = (0, outbound_message_1.makeMsg)(protocol_message_types_1.ProtocolMessageTypes.register_interest_in_coin, pckt);
        this.messageManager.registerFilter({
            messageToSend: msgToSend,
            consumeMessage: (msg) => {
                if (bignumber_1.BigNumber.from(msg.type).toNumber() !== protocol_message_types_1.ProtocolMessageTypes.respond_to_coin_update) {
                    return false;
                }
                const rPckt = serializer_1.Serializer.deserialize(wallet_protocol_1.RespondToCoinUpdates, msg.data);
                if (!rPckt.coinIds.includes(coinId) ||
                    !bignumber_1.BigNumber.from(rPckt.minHeight).eq(minHeight)) {
                    return false;
                }
                const coins = rPckt.coinStates.filter((cs) => util_1.Util.coin.getId(cs.coin) === coinId);
                callback(coins);
                return true;
            },
            deleteAfterFirstMessageConsumed: false,
            expectedMaxRensponseWait: 0
        });
    }
    getPuzzleSolution({ coinId, height }) {
        return __awaiter(this, void 0, void 0, function* () {
            coinId = addressUtil.validateHashString(coinId);
            if (coinId.length === 0)
                return null;
            const pckt = new wallet_protocol_1.RequestPuzzleSolution();
            pckt.coinName = coinId;
            pckt.height = height;
            const msgToSend = (0, outbound_message_1.makeMsg)(protocol_message_types_1.ProtocolMessageTypes.request_puzzle_solution, pckt);
            let respPckt = new wallet_protocol_1.PuzzleSolutionResponse();
            let returnNull = false;
            yield this.messageManager.registerFilter({
                messageToSend: msgToSend,
                consumeMessage: (msg) => {
                    if (bignumber_1.BigNumber.from(msg.type).toNumber() === protocol_message_types_1.ProtocolMessageTypes.reject_puzzle_solution) {
                        const rPckt = serializer_1.Serializer.deserialize(wallet_protocol_1.RejectPuzzleSolution, msg.data);
                        if (rPckt.coinName === coinId &&
                            bignumber_1.BigNumber.from(rPckt.height).toNumber() === height) {
                            returnNull = true;
                            return true;
                        }
                    }
                    if (bignumber_1.BigNumber.from(msg.type).toNumber() === protocol_message_types_1.ProtocolMessageTypes.respond_puzzle_solution) {
                        const rPckt = serializer_1.Serializer.deserialize(wallet_protocol_1.RespondPuzzleSolution, msg.data);
                        if (rPckt.response.coinName === coinId &&
                            bignumber_1.BigNumber.from(rPckt.response.height).toNumber() === height) {
                            respPckt = rPckt.response;
                            return true;
                        }
                    }
                    return false;
                },
            });
            if (returnNull) {
                return null;
            }
            return respPckt;
        });
    }
    getCoinChildren({ coinId }) {
        return __awaiter(this, void 0, void 0, function* () {
            coinId = addressUtil.validateHashString(coinId);
            if (coinId.length === 0)
                return [];
            const pckt = new wallet_protocol_1.RequestChildren();
            pckt.coinName = coinId;
            const msgToSend = (0, outbound_message_1.makeMsg)(protocol_message_types_1.ProtocolMessageTypes.request_children, pckt);
            let respPckt = new wallet_protocol_1.RespondChildren();
            yield this.messageManager.registerFilter({
                messageToSend: msgToSend,
                consumeMessage: (msg) => {
                    if (bignumber_1.BigNumber.from(msg.type).toNumber() !== protocol_message_types_1.ProtocolMessageTypes.respond_children) {
                        return false;
                    }
                    const rPckt = serializer_1.Serializer.deserialize(wallet_protocol_1.RespondChildren, msg.data);
                    if (rPckt.coinStates.length === 0 || rPckt.coinStates[0].coin.parentCoinInfo === coinId) {
                        respPckt = rPckt;
                        return true;
                    }
                    return false;
                },
            });
            const coinStates = respPckt.coinStates;
            return coinStates;
        });
    }
    _headerBlockToProviderBlockHeader(headerBlock, height) {
        var _a, _b;
        const header = new providerTypes.BlockHeader();
        header.height = height;
        header.headerHash = headerBlock.headerHash();
        header.prevBlockHash = headerBlock.foliage.prevBlockHash;
        header.isTransactionBlock = headerBlock.rewardChainBlock.isTransactionBlock;
        header.farmerPuzzleHash = headerBlock.foliage.foliageBlockData.farmerRewardPuzzleHash;
        header.poolPuzzleHash = headerBlock.foliage.foliageBlockData.poolTarget.puzzleHash;
        header.fees = (_b = (_a = headerBlock.transactionsInfo) === null || _a === void 0 ? void 0 : _a.fees) !== null && _b !== void 0 ? _b : null;
        return header;
    }
    getBlockHeader({ height }) {
        return __awaiter(this, void 0, void 0, function* () {
            const pckt = new wallet_protocol_1.RequestBlockHeader();
            pckt.height = height;
            const msgToSend = (0, outbound_message_1.makeMsg)(protocol_message_types_1.ProtocolMessageTypes.request_block_header, pckt);
            let returnNull = false;
            let respPckt = new wallet_protocol_1.RespondBlockHeader();
            yield this.messageManager.registerFilter({
                messageToSend: msgToSend,
                consumeMessage: (msg) => {
                    if (bignumber_1.BigNumber.from(msg.type).toNumber() === protocol_message_types_1.ProtocolMessageTypes.reject_header_request) {
                        const rPckt = serializer_1.Serializer.deserialize(wallet_protocol_1.RejectHeaderRequest, msg.data);
                        if (bignumber_1.BigNumber.from(rPckt.height).toNumber() === height) {
                            returnNull = true;
                            return true;
                        }
                    }
                    if (bignumber_1.BigNumber.from(msg.type).toNumber() === protocol_message_types_1.ProtocolMessageTypes.respond_block_header) {
                        const rPckt = serializer_1.Serializer.deserialize(wallet_protocol_1.RespondBlockHeader, msg.data);
                        if (bignumber_1.BigNumber.from(rPckt.headerBlock.rewardChainBlock.height).toNumber() === height) {
                            respPckt = rPckt;
                            return true;
                        }
                    }
                    return false;
                },
            });
            if (returnNull) {
                return null;
            }
            const headerBlock = respPckt.headerBlock;
            return this._headerBlockToProviderBlockHeader(headerBlock, height);
        });
    }
    getBlocksHeaders({ startHeight, endHeight }) {
        return __awaiter(this, void 0, void 0, function* () {
            const pckt = new wallet_protocol_1.RequestHeaderBlocks();
            pckt.startHeight = startHeight;
            pckt.endHeight = endHeight;
            const msgToSend = (0, outbound_message_1.makeMsg)(protocol_message_types_1.ProtocolMessageTypes.request_header_blocks, pckt);
            let returnNull = false;
            let respPckt = new wallet_protocol_1.RespondHeaderBlocks();
            yield this.messageManager.registerFilter({
                messageToSend: msgToSend,
                consumeMessage: (msg) => {
                    if (bignumber_1.BigNumber.from(msg.type).toNumber() === protocol_message_types_1.ProtocolMessageTypes.reject_header_blocks) {
                        const rPckt = serializer_1.Serializer.deserialize(wallet_protocol_1.RejectHeaderBlocks, msg.data);
                        if (bignumber_1.BigNumber.from(rPckt.startHeight).toNumber() === startHeight &&
                            bignumber_1.BigNumber.from(rPckt.endHeight).toNumber() === endHeight) {
                            returnNull = true;
                            return true;
                        }
                    }
                    if (bignumber_1.BigNumber.from(msg.type).toNumber() === protocol_message_types_1.ProtocolMessageTypes.respond_header_blocks) {
                        const rPckt = serializer_1.Serializer.deserialize(wallet_protocol_1.RespondHeaderBlocks, msg.data);
                        if (bignumber_1.BigNumber.from(rPckt.startHeight).toNumber() === startHeight &&
                            bignumber_1.BigNumber.from(rPckt.endHeight).toNumber() === endHeight) {
                            respPckt = rPckt;
                            return true;
                        }
                    }
                    return false;
                },
            });
            if (returnNull) {
                return null;
            }
            const headers = [];
            for (let i = 0; i < respPckt.headerBlocks.length; ++i) {
                const header = this._headerBlockToProviderBlockHeader(respPckt.headerBlocks[i], bignumber_1.BigNumber.from(respPckt.startHeight).add(i));
                headers.push(header);
            }
            return headers;
        });
    }
    getCoinRemovals({ height, headerHash, coinIds = undefined }) {
        return __awaiter(this, void 0, void 0, function* () {
            headerHash = addressUtil.validateHashString(headerHash);
            if (headerHash.length === 0)
                return null;
            const parsedCoinIds = [];
            if (coinIds !== undefined) {
                for (let i = 0; i < coinIds.length; ++i) {
                    const parsed = addressUtil.validateHashString(coinIds[i]);
                    if (parsed.length === 0)
                        return null;
                    parsedCoinIds.push(parsed);
                }
            }
            const pckt = new wallet_protocol_1.RequestRemovals();
            pckt.height = height;
            pckt.headerHash = headerHash;
            pckt.coinNames = coinIds !== undefined ? parsedCoinIds : null;
            const msgToSend = (0, outbound_message_1.makeMsg)(protocol_message_types_1.ProtocolMessageTypes.request_removals, pckt);
            let returnNull = false;
            let respPckt = new wallet_protocol_1.RespondRemovals();
            yield this.messageManager.registerFilter({
                messageToSend: msgToSend,
                consumeMessage: (msg) => {
                    if (bignumber_1.BigNumber.from(msg.type).toNumber() === protocol_message_types_1.ProtocolMessageTypes.reject_removals_request) {
                        const rPckt = serializer_1.Serializer.deserialize(wallet_protocol_1.RejectRemovalsRequest, msg.data);
                        if (bignumber_1.BigNumber.from(rPckt.height).toNumber() === height &&
                            rPckt.headerHash === headerHash) {
                            returnNull = true;
                            return true;
                        }
                    }
                    if (bignumber_1.BigNumber.from(msg.type).toNumber() === protocol_message_types_1.ProtocolMessageTypes.respond_removals) {
                        const rPckt = serializer_1.Serializer.deserialize(wallet_protocol_1.RespondRemovals, msg.data);
                        if (bignumber_1.BigNumber.from(rPckt.height).toNumber() === height &&
                            rPckt.headerHash === headerHash) {
                            respPckt = rPckt;
                            return true;
                        }
                    }
                    return false;
                },
            });
            if (returnNull) {
                return null;
            }
            const coins = respPckt.coins
                .filter((e) => e[1] !== null)
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                .map((e) => e[1]);
            return coins;
        });
    }
    getCoinAdditions({ height, headerHash, puzzleHashes = undefined }) {
        return __awaiter(this, void 0, void 0, function* () {
            headerHash = addressUtil.validateHashString(headerHash);
            if (headerHash.length === 0)
                return null;
            const parsedPuzzleHashes = [];
            if (puzzleHashes !== undefined) {
                for (let i = 0; i < puzzleHashes.length; ++i) {
                    const parsed = addressUtil.validateHashString(puzzleHashes[i]);
                    if (parsed.length === 0)
                        return null;
                    parsedPuzzleHashes.push(parsed);
                }
            }
            const pckt = new wallet_protocol_1.RequestAdditions();
            pckt.height = height;
            pckt.headerHash = headerHash;
            pckt.puzzleHashes = puzzleHashes !== undefined ? parsedPuzzleHashes : null;
            const msgToSend = (0, outbound_message_1.makeMsg)(protocol_message_types_1.ProtocolMessageTypes.request_additions, pckt);
            let returnNull = false;
            let respPckt = new wallet_protocol_1.RespondAdditions();
            yield this.messageManager.registerFilter({
                messageToSend: msgToSend,
                consumeMessage: (msg) => {
                    if (bignumber_1.BigNumber.from(msg.type).toNumber() === protocol_message_types_1.ProtocolMessageTypes.reject_additions_request) {
                        const rPckt = serializer_1.Serializer.deserialize(wallet_protocol_1.RejectAdditionsRequest, msg.data);
                        if (bignumber_1.BigNumber.from(rPckt.height).toNumber() === height &&
                            rPckt.headerHash === headerHash) {
                            returnNull = true;
                            return true;
                        }
                    }
                    if (bignumber_1.BigNumber.from(msg.type).toNumber() === protocol_message_types_1.ProtocolMessageTypes.respond_additions) {
                        const rPckt = serializer_1.Serializer.deserialize(wallet_protocol_1.RespondAdditions, msg.data);
                        if (bignumber_1.BigNumber.from(rPckt.height).toNumber() === height &&
                            rPckt.headerHash === headerHash) {
                            respPckt = rPckt;
                            return true;
                        }
                    }
                    return false;
                },
            });
            if (returnNull)
                return null;
            const coins = [];
            for (const key of respPckt.coins.keys()) {
                const thing = respPckt.coins[key];
                const coinArr = thing[1];
                for (let j = 0; j < coinArr.length; ++j) {
                    const coin = coinArr[j];
                    coins.push(coin);
                }
            }
            return coins;
        });
    }
    pushSpendBundle(args) {
        return __awaiter(this, void 0, void 0, function* () {
            const pckt = new wallet_protocol_1.SendTransaction();
            pckt.transaction = args.spendBundle;
            const msgToSend = (0, outbound_message_1.makeMsg)(protocol_message_types_1.ProtocolMessageTypes.send_transaction, pckt);
            let respPckt = new wallet_protocol_1.TransactionAck();
            yield this.messageManager.registerFilter({
                messageToSend: msgToSend,
                consumeMessage: (msg) => {
                    if (bignumber_1.BigNumber.from(msg.type).eq(protocol_message_types_1.ProtocolMessageTypes.transaction_ack)) {
                        respPckt = serializer_1.Serializer.deserialize(wallet_protocol_1.TransactionAck, msg.data);
                        return true; // txid, status, and error don't really help
                    }
                    return false;
                },
            });
            // https://github.com/Chia-Network/chia-blockchain/blob/25ab0c90cb34cd048463082801c3cc26bfac389a/chia/types/mempool_inclusion_status.py#L4
            if (respPckt.error === null &&
                [1, 2].includes(bignumber_1.BigNumber.from(respPckt.status).toNumber())) {
                return true;
            }
            return false;
        });
    }
    _doesNotImplementError() {
        throw new Error("LeafletProvider does not implement this method.");
    }
    getAddress() {
        return this._doesNotImplementError();
    }
    transfer(args) {
        return this._doesNotImplementError();
    }
    transferCAT(args) {
        return this._doesNotImplementError();
    }
    acceptOffer(args) {
        return this._doesNotImplementError();
    }
    subscribeToAddressChanges(args) {
        return this._doesNotImplementError();
    }
    signCoinSpends(args) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._doesNotImplementError();
        });
    }
    changeNetwork(args) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._doesNotImplementError();
        });
    }
}
exports.LeafletProvider = LeafletProvider;
//# sourceMappingURL=leaflet_provider.js.map