import { Provider, getBalanceArgs, subscribeToPuzzleHashUpdatesArgs, subscribeToCoinUpdatesArgs, getPuzzleSolutionArgs, getCoinChildrenArgs, getBlockHeaderArgs, getBlocksHeadersArgs, getCoinRemovalsArgs, getCoinAdditionsArgs } from "../provider";
import * as providerTypes from "../provider_types";
import { transferArgs, transferCATArgs, acceptOfferArgs, subscribeToAddressChangesArgs, signCoinSpendsArgs, changeNetworkArgs, pushSpendBundleArgs } from "../provider_args";
import { BigNumber } from "@ethersproject/bignumber";
import { MessageManager } from "./message_manager";
import { IWebSocket } from "./chia_message_channel";
import { SpendBundle } from "../../../util/serializer/types/spend_bundle";
import { Optional } from "../../../util/serializer/basic_types";
import { Network } from "../../../util/network";
export declare class LeafletProvider implements Provider {
    messageManager: MessageManager;
    private blockNumber;
    private network;
    constructor(host: string, apiKey: string, port?: number, network?: Network, webSocketCreateFunc?: (url: string) => IWebSocket);
    connect(): Promise<void>;
    close(): Promise<void>;
    getNetworkId(): Network;
    isConnected(): boolean;
    getBlockNumber(): Promise<providerTypes.Optional<number>>;
    getBalance({ address, puzzleHash, minHeight }: getBalanceArgs): Promise<providerTypes.Optional<BigNumber>>;
    subscribeToPuzzleHashUpdates({ puzzleHash, callback, minHeight }: subscribeToPuzzleHashUpdatesArgs): void;
    subscribeToCoinUpdates({ coinId, callback, minHeight }: subscribeToCoinUpdatesArgs): void;
    getPuzzleSolution({ coinId, height }: getPuzzleSolutionArgs): Promise<providerTypes.Optional<providerTypes.PuzzleSolution>>;
    getCoinChildren({ coinId }: getCoinChildrenArgs): Promise<providerTypes.CoinState[]>;
    private _headerBlockToProviderBlockHeader;
    getBlockHeader({ height }: getBlockHeaderArgs): Promise<providerTypes.Optional<providerTypes.BlockHeader>>;
    getBlocksHeaders({ startHeight, endHeight }: getBlocksHeadersArgs): Promise<providerTypes.Optional<providerTypes.BlockHeader[]>>;
    getCoinRemovals({ height, headerHash, coinIds }: getCoinRemovalsArgs): Promise<providerTypes.Optional<providerTypes.Coin[]>>;
    getCoinAdditions({ height, headerHash, puzzleHashes }: getCoinAdditionsArgs): Promise<providerTypes.Optional<providerTypes.Coin[]>>;
    pushSpendBundle(args: pushSpendBundleArgs): Promise<boolean>;
    private _doesNotImplementError;
    getAddress(): Promise<string>;
    transfer(args: transferArgs): Promise<Optional<SpendBundle>>;
    transferCAT(args: transferCATArgs): Promise<Optional<SpendBundle>>;
    acceptOffer(args: acceptOfferArgs): Promise<Optional<SpendBundle>>;
    subscribeToAddressChanges(args: subscribeToAddressChangesArgs): void;
    signCoinSpends(args: signCoinSpendsArgs): Promise<Optional<SpendBundle>>;
    changeNetwork(args: changeNetworkArgs): Promise<boolean>;
}
