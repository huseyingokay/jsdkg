"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageManager = void 0;
const bignumber_1 = require("@ethersproject/bignumber");
const serializer_1 = require("../../../util/serializer/serializer");
const outbound_message_1 = require("../../../util/serializer/types/outbound_message");
const protocol_message_types_1 = require("../../../util/serializer/types/protocol_message_types");
const sleep = (ms) => new Promise(r => setTimeout(r, ms));
class MessageManager {
    constructor(createMessageChannel, timeout = 500, controllerSleepBetweenChecks = 1000) {
        this.open = false;
        this._canSendMessage = false;
        this._filters = [];
        this._skipTimeoutWait = false;
        this._createMessageChannel = createMessageChannel;
        this._timeout = timeout;
        this._controllerSleepBetweenChecks = controllerSleepBetweenChecks;
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            // push a filter that listens for 'new peak wallet' packets
            const filter = {
                messageToSend: undefined,
                consumeMessage: (msg) => bignumber_1.BigNumber.from(msg.type).toNumber() === protocol_message_types_1.ProtocolMessageTypes.new_peak_wallet ||
                    bignumber_1.BigNumber.from(msg.type).toNumber() === protocol_message_types_1.ProtocolMessageTypes.handshake,
                deleteAfterFirstMessageConsumed: false,
                expectedMaxRensponseWait: 60 * 1000,
            };
            this._filters.push({
                filter: filter,
                lastMessageReceived: 0,
                // eslint-disable-next-line @typescript-eslint/no-empty-function
                resolvePromise: () => { },
            });
            // initialize other things
            this._canSendMessage = false;
            this._skipTimeoutWait = true;
            this.open = true;
            this._controller = this._controllerFunction();
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            this.open = false;
            yield this._controller;
        });
    }
    registerFilter({ messageToSend, consumeMessage, deleteAfterFirstMessageConsumed = true, expectedMaxRensponseWait = 4200 }) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise(resolve => {
                const timestamp = new Date().getTime();
                const filterToPush = {
                    filter: { messageToSend, consumeMessage, deleteAfterFirstMessageConsumed, expectedMaxRensponseWait },
                    lastMessageReceived: timestamp,
                    resolvePromise: resolve
                };
                this._filters.push(filterToPush);
                if (messageToSend != null && this._canSendMessage) {
                    this._msgChannel.sendMessage(messageToSend);
                }
            });
        });
    }
    _handleMessage(rawMsg) {
        const msg = serializer_1.Serializer.deserialize(outbound_message_1.Message, rawMsg);
        for (let i = 0; i < this._filters.length; ++i) {
            const filter = this._filters[i].filter;
            try {
                if (filter.consumeMessage(msg)) {
                    const timestamp = new Date().getTime();
                    this._filters[i].lastMessageReceived = timestamp;
                    this._filters[i].resolvePromise(msg);
                    // eslint-disable-next-line @typescript-eslint/no-empty-function
                    this._filters[i].resolvePromise = () => { };
                    if (filter.deleteAfterFirstMessageConsumed) {
                        this._filters.splice(i, 1);
                        i--;
                    }
                }
            }
            catch (_) {
                // do nothing
            }
        }
    }
    _controllerFunction() {
        return __awaiter(this, void 0, void 0, function* () {
            while (this.open) {
                const timestamp = new Date().getTime();
                let restart = !this._canSendMessage || !this._msgChannel.isConnected();
                for (let i = 0; i < this._filters.length && !restart; ++i) {
                    const filter = this._filters[i].filter;
                    if (filter.expectedMaxRensponseWait !== 0 &&
                        this._filters[i].lastMessageReceived + filter.expectedMaxRensponseWait < timestamp) {
                        restart = true;
                    }
                }
                if (restart) {
                    this._canSendMessage = false;
                    if (this._skipTimeoutWait) {
                        this._skipTimeoutWait = false;
                    }
                    else {
                        yield sleep(this._timeout);
                    }
                    this._msgChannel = yield this._createMessageChannel((msg) => this._handleMessage(msg));
                    yield this._msgChannel.connect();
                    this._canSendMessage = this._msgChannel.isConnected();
                    for (let i = 0; i < this._filters.length && this._canSendMessage; ++i) {
                        const filter = this._filters[i].filter;
                        this._filters[i].lastMessageReceived = new Date().getTime();
                        if (filter.messageToSend !== undefined) {
                            this._msgChannel.sendMessage(filter.messageToSend);
                        }
                    }
                }
                else {
                    yield sleep(this._controllerSleepBetweenChecks);
                }
            }
            this._msgChannel.close();
        });
    }
}
exports.MessageManager = MessageManager;
//# sourceMappingURL=message_manager.js.map