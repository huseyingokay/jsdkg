"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MnemonicUtils = void 0;
const crypto_js_1 = __importDefault(require("crypto-js"));
const bip39_word_list_1 = require("./bip39_word_list");
const clvm_1 = require("clvm");
class MnemonicUtils {
    static stdHash(data) {
        return crypto_js_1.default.enc.Hex.stringify(crypto_js_1.default.SHA256(crypto_js_1.default.enc.Hex.parse(data)));
    }
    // https://stackoverflow.com/questions/45053624/convert-hex-to-binary-in-javascript
    static hex2bin(hex) {
        hex = hex.replace("0x", "").toLowerCase();
        let out = "";
        for (const c of hex) {
            let b = parseInt(c, 16).toString(2);
            if (b.length < 4) {
                b = "0".repeat(4 - b.length) + b;
            }
            out += b;
        }
        return out;
    }
    static bin2hex(bin) {
        let out = "";
        let x = "";
        for (const c of bin) {
            x += c;
            if (x.length === 4) {
                out += parseInt(x, 2).toString(16);
                x = "";
            }
        }
        return out;
    }
    // https://github.com/Chia-Network/chia-blockchain/blob/main/chia/util/keychain.py#L147
    static bytesToMnemonic(mnemonicBytes) {
        if (![16, 20, 24, 28, 32].includes(mnemonicBytes.length / 2)) {
            throw new Error(`Data length should be one of the following: [16, 20, 24, 28, 32], but it is ${mnemonicBytes.length / 2}.`);
        }
        const CS = Math.floor(mnemonicBytes.length / 8);
        const checksum = this.hex2bin(this.stdHash(mnemonicBytes)).slice(0, CS);
        const bitarray = this.hex2bin(mnemonicBytes) + checksum;
        const mnemonics = [];
        const lim = Math.floor(bitarray.length / 11);
        for (let i = 0; i < lim; ++i) {
            const start = i * 11;
            const end = start + 11;
            const bits = bitarray.slice(start, end);
            const mWordPosition = parseInt(bits, 2);
            const mWord = bip39_word_list_1.BIP39_WORD_LIST[mWordPosition];
            mnemonics.push(mWord);
        }
        return mnemonics.join(" ");
    }
    // https://github.com/Chia-Network/chia-blockchain/blob/main/chia/util/keychain.py#L172
    static bytesFromMnemonic(mnemonicStr) {
        const mnemonic = mnemonicStr.split(" ");
        if (![12, 15, 18, 21, 24].includes(mnemonic.length)) {
            throw new Error("Invalid mnemonic length");
        }
        const wordList = new Map();
        for (let i = 0; i < bip39_word_list_1.BIP39_WORD_LIST.length; ++i) {
            wordList.set(bip39_word_list_1.BIP39_WORD_LIST[i], i);
        }
        let bitArray = "";
        for (let i = 0; i < mnemonic.length; ++i) {
            const word = mnemonic[i];
            const value = wordList.get(word);
            let toAdd = value === null || value === void 0 ? void 0 : value.toString(2);
            if (toAdd === undefined) {
                throw new Error(`'${word}' is not in the mnemonic dictionary; may be misspelled`);
            }
            if (toAdd.length < 11) {
                toAdd = "0".repeat(11 - toAdd.length) + toAdd;
            }
            bitArray += toAdd;
        }
        const CS = Math.floor(mnemonic.length / 3);
        const ENT = mnemonic.length * 11 - CS;
        const entropyBytes = this.bin2hex(bitArray.slice(0, ENT));
        const checksumBytes = bitArray.slice(ENT);
        const checksum = this.hex2bin(this.stdHash(entropyBytes)).slice(0, CS);
        if (checksum !== checksumBytes) {
            throw new Error("Invalid order of mnemonic words");
        }
        return entropyBytes;
    }
    // https://github.com/Chia-Network/chia-blockchain/blob/main/chia/util/keychain.py#L203
    static mnemonicToSeed(mnemonic, passphrase) {
        // Uses BIP39 standard to derive a seed from entropy bytes.
        const saltStr = "mnemonic" + passphrase;
        const salt = saltStr.normalize("NFKD");
        const mnemonicNormalized = mnemonic.normalize("NFKD");
        const res = crypto_js_1.default.enc.Hex.stringify(crypto_js_1.default.PBKDF2(mnemonicNormalized, salt, {
            iterations: 2048,
            hasher: crypto_js_1.default.algo.SHA512,
            keySize: 16
        }));
        return res;
    }
    // https://github.com/Chia-Network/chia-blockchain/blob/a4ec7e7cb8d8ecfa2a50c038e5dd94ef3e620c6c/chia/cmds/keys_funcs.py#L644
    static privateKeyFromMnemonic(mnemonic, passphrase) {
        const { AugSchemeMPL } = (0, clvm_1.getBLSModule)();
        const seed = this.mnemonicToSeed(mnemonic, passphrase !== null && passphrase !== void 0 ? passphrase : "");
        return AugSchemeMPL.key_gen(Buffer.from(seed, "hex"));
    }
}
exports.MnemonicUtils = MnemonicUtils;
//# sourceMappingURL=mnemonic.js.map