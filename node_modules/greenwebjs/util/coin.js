"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoinUtil = void 0;
const bignumber_1 = require("@ethersproject/bignumber");
const clvm_1 = require("clvm");
const _1 = require(".");
class CoinUtil {
    amountToBytes(amount) {
        amount = bignumber_1.BigNumber.from(amount);
        const initialHexLength = amount.toHexString().length;
        if (amount.eq(0)) {
            return "";
        }
        const isNegative = amount.lt(0);
        if (isNegative) {
            amount = bignumber_1.BigNumber.from("0x" + "f".repeat(amount.toHexString().length - 3) // prefix is -0x
            ).add(1).add(amount);
        }
        let hexStr = amount.toHexString().slice(2);
        while (isNegative && initialHexLength - 3 > hexStr.length) {
            hexStr = "00" + hexStr;
        }
        const firstByte = bignumber_1.BigNumber.from("0x" + hexStr.slice(0, 2)).toNumber();
        if (isNegative && (firstByte & 0x80) === 0) {
            hexStr = "ff" + hexStr;
        }
        if (!isNegative && (firstByte & 0x80) !== 0) {
            hexStr = "00" + hexStr;
        }
        return hexStr;
    }
    getId(coin) {
        const toHash = coin.parentCoinInfo + coin.puzzleHash + this.amountToBytes(coin.amount);
        return _1.Util.stdHash(toHash);
    }
    getName(coin) {
        return this.getId(coin);
    }
    toProgram(coin) {
        return clvm_1.SExp.to([
            clvm_1.Bytes.from(coin.parentCoinInfo, "hex"),
            clvm_1.Bytes.from(coin.puzzleHash, "hex"),
            clvm_1.Bytes.from(this.amountToBytes(coin.amount), "hex"),
        ]);
    }
}
exports.CoinUtil = CoinUtil;
//# sourceMappingURL=coin.js.map