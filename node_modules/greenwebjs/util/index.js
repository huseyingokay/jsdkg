"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Util = void 0;
const bignumber_1 = require("@ethersproject/bignumber");
const address_1 = require("./address");
const coin_1 = require("./coin");
const goby_1 = require("./goby");
const key_1 = require("./key");
const network_1 = require("./network");
const serializer_1 = require("./serializer");
const sexp_1 = require("./sexp");
const crypto_js_1 = __importDefault(require("crypto-js"));
class Util {
    static formatToken(amount, amountPerUnit = 1000) {
        try {
            amount = bignumber_1.BigNumber.from(amount);
        }
        catch (_) {
            amount = bignumber_1.BigNumber.from(0); // amount was NaN
        }
        try {
            amountPerUnit = bignumber_1.BigNumber.from(amountPerUnit);
        }
        catch (_) {
            amountPerUnit = bignumber_1.BigNumber.from(1); // amountPerUnit was NaN
        }
        if (amountPerUnit.eq(0)) {
            amountPerUnit = bignumber_1.BigNumber.from(1);
        }
        const wholeUnits = amount.div(amountPerUnit);
        let decimalThing = amount.mod(amountPerUnit).toString();
        const targetLen = amountPerUnit.toString().length - 1;
        if (decimalThing.length < targetLen) {
            decimalThing = "0".repeat(targetLen - decimalThing.length) + decimalThing;
        }
        while (decimalThing.length > 1 && decimalThing[decimalThing.length - 1] === "0") {
            decimalThing = decimalThing.slice(0, -1);
        }
        return `${wholeUnits.toString()}.${decimalThing}`;
    }
    static parseToken(s, amountPerUnit = 1000) {
        amountPerUnit = bignumber_1.BigNumber.from(amountPerUnit);
        let dots = 0;
        let valid = true;
        for (let i = 0; i < s.length && valid; ++i) {
            if (s.charAt(i) === ".") {
                dots += 1;
            }
            else if (!/^\d$/.test(s.charAt(i))) {
                valid = false;
            }
        }
        let wholeUnits = bignumber_1.BigNumber.from(0);
        let amountAfterDot = bignumber_1.BigNumber.from(0);
        if (dots === 0 && valid) {
            wholeUnits = bignumber_1.BigNumber.from(s);
        }
        else if (dots === 1 && valid) {
            const arr = s.split(".");
            wholeUnits = bignumber_1.BigNumber.from(arr[0]);
            let amountAfterDotS = arr[1];
            const missingZeros = amountPerUnit.toString().length - amountAfterDotS.length - 1;
            if (missingZeros > 0) {
                amountAfterDotS = amountAfterDotS + "0".repeat(missingZeros);
            }
            amountAfterDot = bignumber_1.BigNumber.from(amountAfterDotS);
            if (amountAfterDot.gt(amountPerUnit)) {
                valid = false;
            }
        }
        else {
            valid = false;
        }
        if (valid) {
            return wholeUnits.mul(amountPerUnit).add(amountAfterDot);
        }
        else {
            throw new Error("The given string is not valid.");
        }
    }
    static formatChia(mojos) {
        return Util.formatToken(mojos, Util.mojoPerXCH);
    }
    static parseChia(s) {
        return Util.parseToken(s, Util.mojoPerXCH);
    }
    static stdHash(toHash) {
        return crypto_js_1.default.enc.Hex.stringify(crypto_js_1.default.SHA256(crypto_js_1.default.enc.Hex.parse(toHash)));
    }
    static hexlify(value) {
        return value.startsWith("0x") ? value : `0x${value}`;
    }
    static dehexlify(value) {
        if (value === null)
            return null;
        return value.startsWith("0x") ? value.slice(2) : value;
    }
}
exports.Util = Util;
_a = Util;
Util.address = new address_1.AddressUtil();
Util.coin = new coin_1.CoinUtil();
Util.serializer = new serializer_1.SerializerUtil();
Util.network = new network_1.NetworkUtil();
Util.sexp = new sexp_1.SExpUtil();
Util.goby = new goby_1.GobyUtil();
Util.key = new key_1.KeyUtil();
Util.mojoPerXCH = bignumber_1.BigNumber.from(1000000000000);
Util.unhexlify = _a.dehexlify;
//# sourceMappingURL=index.js.map