import { BigNumberish } from "@ethersproject/bignumber";
import { SExp } from "clvm";
import { bytes, Coin, uint } from "../../xch/providers/provider_types";
import { ConditionOpcode } from "./condition_opcodes";
import { ConditionWithArgs } from "./condition_with_args";
export declare type ConditionsDict = Map<ConditionOpcode, ConditionWithArgs[]>;
export declare class SExpUtil {
    readonly MAX_BLOCK_COST_CLVM = 11000000000;
    fromHex(hex: bytes): SExp;
    toHex(sexp: SExp | null | undefined): bytes;
    bytesToAtom(data: bytes): SExp;
    run(program: SExp, solution: SExp, max_cost?: number): SExp;
    runWithCost(program: SExp, solution: SExp, max_cost?: number): [SExp, number];
    readonly SHA256TREE_MODULE_PROGRAM: SExp;
    sha256tree(program: SExp): bytes;
    conditionsDictForSolution(puzzleReveal: SExp, solution: SExp, maxCost: number): [boolean, ConditionsDict | null, number];
    conditionsForSolution(puzzleReveal: SExp, solution: SExp, maxCost: number): [boolean, ConditionWithArgs[] | null, number];
    parseSExpToConditions(sexp: SExp): [boolean, ConditionWithArgs[] | null];
    parseSExpToCondition(sexp: SExp): [boolean, ConditionWithArgs | null];
    asAtomList(sexp: SExp): bytes[];
    conditionsByOpcode(conditions: ConditionWithArgs[]): ConditionsDict;
    pkmPairsForConditionsDict(conditionsDict: ConditionsDict, coinName: bytes, additionalData: bytes): Array<[bytes, bytes]>;
    readonly CURRY_PROGRAM: SExp;
    curry(program: SExp, args: SExp[]): SExp;
    readonly P2_DELEGATED_PUZZLE_OR_HIDDEN_PUZZLE_PROGRAM_MOD: SExp;
    readonly DEFAULT_HIDDEN_PUZZLE_PROGRAM: SExp;
    readonly DEFAULT_HIDDEN_PUZZLE_HASH = "711d6c4e32c92e53179b199484cf8c897542bc57f2b22582799f9d657eec4699";
    readonly CALCULATE_SYNTHETIC_PUBLIC_KEY_PROGRAM: SExp;
    calculateSyntheticPublicKey(publicKey: any, hiddenPuzzleHash?: string): any;
    standardCoinPuzzle(key: any, isSyntheticKey?: boolean): SExp;
    readonly P2_CONDITIONS_PROGRAM: SExp;
    standardCoinSolution(conditions: SExp[]): SExp;
    uncurry(program: SExp): [SExp, SExp[]] | null;
    private _matchQuotedProgram;
    private _matchCurriedArgs;
    private _matchCurriedArgsHelper;
    private _matchQuotedAtom;
    readonly CAT_PROGRAM_MOD: SExp;
    readonly CAT_PROGRAM_MOD_HASH: string;
    CATPuzzle(TAILProgramHash: bytes, innerPuzzle: SExp): SExp;
    CATSolution(innerPuzzleSolution: SExp, lineageProof: SExp | null, prevCoinId: bytes, thisCoinInfo: Coin, nextCoinProof: Coin, prevSubtotal: BigNumberish, extraDelta: BigNumberish): SExp;
    readonly GENESIS_BY_COIN_ID_TAIL_MOD: SExp;
    genesisByCoinIdTAIL(genesisId: bytes): SExp;
    readonly GENESIS_BY_PUZZLE_HASH_TAIL_MOD: SExp;
    genesisByPuzzleHashTAIL(puzzleHash: bytes): SExp;
    readonly EVERYTHING_WITH_SIGNATURE_TAIL_MOD: SExp;
    everythingWithSignatureTAIL(pubKey: bytes): SExp;
    readonly DELEGATED_TAIL_MOD: SExp;
    delegatedTAIL(pubKey: bytes): SExp;
    readonly SINGLETON_TOP_LAYER_v1_1_PROGRAM_MOD: SExp;
    readonly SINGLETON_TOP_LAYER_v1_1_PROGRAM_MOD_HASH = "7faa3253bfddd1e0decb0906b2dc6247bbc4cf608f58345d173adb63e8b47c9f";
    readonly SINGLETON_LAUNCHER_PROGRAM: SExp;
    readonly SINGLETON_LAUNCHER_PROGRAM_HASH = "eff07522495060c066f66f32acc2a77e3a3e737aca8baea4d1a64ea4cdc13da9";
    singletonPuzzle(launcherId: bytes, innerPuzzle: SExp): SExp;
    singletonSolution(lineageProof: SExp, amount: uint, innerSolution: SExp): SExp;
    singletonLauncherSolution(singletonFullPuzzleHash: bytes, amount: uint, keyValueList: Array<[string, string]>): SExp;
    readonly P2_SINGLETON_PROGRAM_MOD: SExp;
    payToSingletonPuzzle(launcherId: bytes): SExp;
    payToSingletonSolution(singletonInnerPuzzleHash: bytes, myId: bytes): SExp;
}
